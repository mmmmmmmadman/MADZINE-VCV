#include "plugin.hpp"
#include <chrono>

struct RUNSHOW : Module {
    enum ParamId {
        RESET_PARAM,
        START_STOP_PARAM,
        PARAMS_LEN
    };
    enum InputId {
        CLOCK_INPUT,
        RESET_INPUT,
        START_STOP_INPUT,
        INPUTS_LEN
    };
    enum OutputId {
        BAR_4_OUTPUT,
        BAR_8_OUTPUT,
        BAR_16_OUTPUT,
        BAR_32_OUTPUT,
        OUTPUTS_LEN
    };
    enum LightId {
        BAR_4_LIGHT,
        BAR_8_LIGHT,
        BAR_16_LIGHT,
        BAR_32_LIGHT,
        BEAT_LIGHT,
        PROGRESS_LIGHTS,
        LIGHTS_LEN = PROGRESS_LIGHTS + 64
    };

    dsp::SchmittTrigger clockTrigger;
    dsp::SchmittTrigger resetTrigger;
    dsp::SchmittTrigger startStopTrigger;
    dsp::SchmittTrigger resetButtonTrigger;
    dsp::SchmittTrigger startStopButtonTrigger;

    bool running = false;
    int clockCount = 0;
    int currentBar = 0;
    int quarter_notes = 0;  // 4分音符計數
    int eighth_notes = 0;   // 8分音符計數
    int sixteenth_notes = 0; // 16分音符計數

    std::chrono::steady_clock::time_point startTime;
    std::chrono::steady_clock::time_point lastUpdateTime;
    float elapsedSeconds = 0.f;

    dsp::PulseGenerator bar4Pulse;
    dsp::PulseGenerator bar8Pulse;
    dsp::PulseGenerator bar16Pulse;
    dsp::PulseGenerator bar32Pulse;

    RUNSHOW() {
        config(PARAMS_LEN, INPUTS_LEN, OUTPUTS_LEN, LIGHTS_LEN);

        configParam(RESET_PARAM, 0.f, 1.f, 0.f, "Reset");
        configParam(START_STOP_PARAM, 0.f, 1.f, 0.f, "Start/Stop");

        configInput(CLOCK_INPUT, "Clock");
        configInput(RESET_INPUT, "Reset");
        configInput(START_STOP_INPUT, "Start/Stop");

        configOutput(BAR_4_OUTPUT, "4 Bar Trigger");
        configOutput(BAR_8_OUTPUT, "8 Bar Trigger");
        configOutput(BAR_16_OUTPUT, "16 Bar Trigger");
        configOutput(BAR_32_OUTPUT, "32 Bar Trigger");

        configLight(BAR_4_LIGHT, "4 Bar");
        configLight(BAR_8_LIGHT, "8 Bar");
        configLight(BAR_16_LIGHT, "16 Bar");
        configLight(BAR_32_LIGHT, "32 Bar");
        configLight(BEAT_LIGHT, "Beat");
        for (int i = 0; i < 64; i++) {
            configLight(PROGRESS_LIGHTS + i, string::f("Progress %d", i+1));
        }
    }

    void process(const ProcessArgs& args) override {
        bool resetTriggered = resetTrigger.process(inputs[RESET_INPUT].getVoltage()) ||
                              resetButtonTrigger.process(params[RESET_PARAM].getValue());

        bool startStopTriggered = startStopTrigger.process(inputs[START_STOP_INPUT].getVoltage()) ||
                                  startStopButtonTrigger.process(params[START_STOP_PARAM].getValue());

        if (startStopTriggered) {
            running = !running;
            if (running) {
                startTime = std::chrono::steady_clock::now();
                lastUpdateTime = startTime;
            }
        }

        if (resetTriggered) {
            clockCount = 0;
            currentBar = 0;
            quarter_notes = 0;
            eighth_notes = 0;
            sixteenth_notes = 0;
            elapsedSeconds = 0.f;
            startTime = std::chrono::steady_clock::now();
            lastUpdateTime = startTime;

            lights[BAR_4_LIGHT].setBrightness(0.f);
            lights[BAR_8_LIGHT].setBrightness(0.f);
            lights[BAR_16_LIGHT].setBrightness(0.f);
            lights[BAR_32_LIGHT].setBrightness(0.f);
            lights[BEAT_LIGHT].setBrightness(0.f);
            for (int i = 0; i < 64; i++) {
                lights[PROGRESS_LIGHTS + i].setBrightness(0.f);
            }
        }

        if (running) {
            auto currentTime = std::chrono::steady_clock::now();
            elapsedSeconds = std::chrono::duration<float>(currentTime - startTime).count();

            if (clockTrigger.process(inputs[CLOCK_INPUT].getVoltage())) {
                clockCount++;

                // 假設每個 clock 是 16 分音符
                sixteenth_notes++;

                // 每 2 個 16 分音符 = 1 個 8 分音符
                if (clockCount % 2 == 0) {
                    eighth_notes++;
                }

                // 每 4 個 16 分音符 = 1 個 4 分音符 (節拍)
                if (clockCount % 4 == 0) {
                    quarter_notes++;
                    // Beat light flash
                    lights[BEAT_LIGHT].setBrightness(1.f);
                }

                // Update progress lights (64 steps = 4 bars)
                // Using column-major order: each column is one bar (16 steps)
                int totalStep = clockCount % 64;

                for (int i = 0; i < 64; i++) {
                    // Convert sequential step to column-major index
                    int sequentialBar = i / 16;  // Which bar (0-3)
                    int stepInBar = i % 16;       // Which step in the bar (0-15)
                    int lightIndex = sequentialBar * 16 + stepInBar;  // Column-major indexing

                    // Light up if we've passed this step
                    if (i <= totalStep) {
                        lights[PROGRESS_LIGHTS + lightIndex].setBrightness(1.f);
                    } else {
                        lights[PROGRESS_LIGHTS + lightIndex].setBrightness(0.1f);
                    }
                }

                // 每 16 個 16 分音符 = 1 小節 (4/4 拍)
                if (clockCount % 16 == 0) {
                    currentBar++;

                    if (currentBar % 4 == 0) {
                        bar4Pulse.trigger(1e-3f);
                        lights[BAR_4_LIGHT].setBrightness(1.f);
                    }

                    if (currentBar % 8 == 0) {
                        bar8Pulse.trigger(1e-3f);
                        lights[BAR_8_LIGHT].setBrightness(1.f);
                    }

                    if (currentBar % 16 == 0) {
                        bar16Pulse.trigger(1e-3f);
                        lights[BAR_16_LIGHT].setBrightness(1.f);
                    }

                    if (currentBar % 32 == 0) {
                        bar32Pulse.trigger(1e-3f);
                        lights[BAR_32_LIGHT].setBrightness(1.f);
                    }
                }
            }
        }

        outputs[BAR_4_OUTPUT].setVoltage(bar4Pulse.process(args.sampleTime) ? 10.f : 0.f);
        outputs[BAR_8_OUTPUT].setVoltage(bar8Pulse.process(args.sampleTime) ? 10.f : 0.f);
        outputs[BAR_16_OUTPUT].setVoltage(bar16Pulse.process(args.sampleTime) ? 10.f : 0.f);
        outputs[BAR_32_OUTPUT].setVoltage(bar32Pulse.process(args.sampleTime) ? 10.f : 0.f);

        float lightDecay = 5.f * args.sampleTime;
        lights[BAR_4_LIGHT].setBrightness(std::max(0.f, lights[BAR_4_LIGHT].getBrightness() - lightDecay));
        lights[BAR_8_LIGHT].setBrightness(std::max(0.f, lights[BAR_8_LIGHT].getBrightness() - lightDecay));
        lights[BAR_16_LIGHT].setBrightness(std::max(0.f, lights[BAR_16_LIGHT].getBrightness() - lightDecay));
        lights[BAR_32_LIGHT].setBrightness(std::max(0.f, lights[BAR_32_LIGHT].getBrightness() - lightDecay));

        // Faster decay for beat light
        lights[BEAT_LIGHT].setBrightness(std::max(0.f, lights[BEAT_LIGHT].getBrightness() - lightDecay * 3.f));
    }

    json_t* dataToJson() override {
        json_t* rootJ = json_object();
        json_object_set_new(rootJ, "running", json_boolean(running));
        json_object_set_new(rootJ, "clockCount", json_integer(clockCount));
        json_object_set_new(rootJ, "currentBar", json_integer(currentBar));
        json_object_set_new(rootJ, "quarter_notes", json_integer(quarter_notes));
        json_object_set_new(rootJ, "eighth_notes", json_integer(eighth_notes));
        json_object_set_new(rootJ, "sixteenth_notes", json_integer(sixteenth_notes));
        json_object_set_new(rootJ, "elapsedSeconds", json_real(elapsedSeconds));
        return rootJ;
    }

    void dataFromJson(json_t* rootJ) override {
        json_t* runningJ = json_object_get(rootJ, "running");
        if (runningJ)
            running = json_boolean_value(runningJ);

        json_t* clockCountJ = json_object_get(rootJ, "clockCount");
        if (clockCountJ)
            clockCount = json_integer_value(clockCountJ);

        json_t* currentBarJ = json_object_get(rootJ, "currentBar");
        if (currentBarJ)
            currentBar = json_integer_value(currentBarJ);

        json_t* quarter_notesJ = json_object_get(rootJ, "quarter_notes");
        if (quarter_notesJ)
            quarter_notes = json_integer_value(quarter_notesJ);

        json_t* eighth_notesJ = json_object_get(rootJ, "eighth_notes");
        if (eighth_notesJ)
            eighth_notes = json_integer_value(eighth_notesJ);

        json_t* sixteenth_notesJ = json_object_get(rootJ, "sixteenth_notes");
        if (sixteenth_notesJ)
            sixteenth_notes = json_integer_value(sixteenth_notesJ);

        json_t* elapsedSecondsJ = json_object_get(rootJ, "elapsedSeconds");
        if (elapsedSecondsJ)
            elapsedSeconds = json_real_value(elapsedSecondsJ);
    }
};

struct RUNSHOWWidget : ModuleWidget {

    RUNSHOWWidget(RUNSHOW* module) {
        setModule(module);
        setPanel(createPanel(asset::plugin(pluginInstance, "res/12HP.svg")));
        box.size = Vec(12 * RACK_GRID_WIDTH, RACK_GRID_HEIGHT);

        // Add screws
        addChild(createWidget<ScrewSilver>(Vec(RACK_GRID_WIDTH, 0)));
        addChild(createWidget<ScrewSilver>(Vec(box.size.x - 2 * RACK_GRID_WIDTH, 0)));
        addChild(createWidget<ScrewSilver>(Vec(RACK_GRID_WIDTH, RACK_GRID_HEIGHT - RACK_GRID_WIDTH)));
        addChild(createWidget<ScrewSilver>(Vec(box.size.x - 2 * RACK_GRID_WIDTH, RACK_GRID_HEIGHT - RACK_GRID_WIDTH)));

        // Top controls section
        float topY = 30;

        // Start/Stop button and CV closely paired
        addParam(createParamCentered<VCVButton>(Vec(30, topY), module, RUNSHOW::START_STOP_PARAM));
        addInput(createInputCentered<PJ301MPort>(Vec(30, topY + 20), module, RUNSHOW::START_STOP_INPUT));

        // Reset button and CV closely paired
        addParam(createParamCentered<VCVButton>(Vec(90, topY), module, RUNSHOW::RESET_PARAM));
        addInput(createInputCentered<PJ301MPort>(Vec(90, topY + 20), module, RUNSHOW::RESET_INPUT));

        // Clock input and beat indicator
        addInput(createInputCentered<PJ301MPort>(Vec(60, topY), module, RUNSHOW::CLOCK_INPUT));
        addChild(createLightCentered<LargeLight<RedLight>>(Vec(60, topY + 20), module, RUNSHOW::BEAT_LIGHT));

        // Progress lights (16 rows x 4 columns) - vertical arrangement
        float progressX = 30;  // Starting X position
        float progressY = 80;  // Starting Y position
        float colSpacing = 30; // Space between columns
        float rowSpacing = 10; // Space between rows

        for (int col = 0; col < 4; col++) {
            float x = progressX + (col * colSpacing);
            for (int row = 0; row < 16; row++) {
                float y = progressY + (row * rowSpacing);
                int lightIndex = col * 16 + row;  // Column-major order

                // Different color for each column
                if (col == 0) {
                    // Red for first column
                    addChild(createLightCentered<SmallLight<RedLight>>(Vec(x, y), module, RUNSHOW::PROGRESS_LIGHTS + lightIndex));
                } else if (col == 1) {
                    // Yellow for second column
                    addChild(createLightCentered<SmallLight<YellowLight>>(Vec(x, y), module, RUNSHOW::PROGRESS_LIGHTS + lightIndex));
                } else if (col == 2) {
                    // Green for third column
                    addChild(createLightCentered<SmallLight<GreenLight>>(Vec(x, y), module, RUNSHOW::PROGRESS_LIGHTS + lightIndex));
                } else {
                    // Blue for fourth column
                    addChild(createLightCentered<SmallLight<BlueLight>>(Vec(x, y), module, RUNSHOW::PROGRESS_LIGHTS + lightIndex));
                }
            }

            // Bar indicator light above each column
            addChild(createLightCentered<MediumLight<WhiteLight>>(Vec(x, progressY - 15), module,
                col == 0 ? RUNSHOW::BAR_4_LIGHT :
                col == 1 ? RUNSHOW::BAR_8_LIGHT :
                col == 2 ? RUNSHOW::BAR_16_LIGHT :
                RUNSHOW::BAR_32_LIGHT));
        }

        // Trigger outputs at the bottom, aligned with each column
        float outputY = 280;
        for (int col = 0; col < 4; col++) {
            float x = progressX + (col * colSpacing);
            addOutput(createOutputCentered<PJ301MPort>(Vec(x, outputY), module,
                col == 0 ? RUNSHOW::BAR_4_OUTPUT :
                col == 1 ? RUNSHOW::BAR_8_OUTPUT :
                col == 2 ? RUNSHOW::BAR_16_OUTPUT :
                RUNSHOW::BAR_32_OUTPUT));
        }
    }
};

Model* modelRUNSHOW = createModel<RUNSHOW, RUNSHOWWidget>("RUNSHOW");