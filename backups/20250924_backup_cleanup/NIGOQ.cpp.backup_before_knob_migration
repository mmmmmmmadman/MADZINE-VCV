#include "plugin.hpp"
#include <cmath>
#include "dsp/resampler.hpp"

// ===== GUI Components =====

struct EnhancedTextLabel : TransparentWidget {
    std::string text;
    float fontSize;
    NVGcolor color;
    bool bold;

    EnhancedTextLabel(Vec pos, Vec size, std::string text, float fontSize = 12.f,
                      NVGcolor color = nvgRGB(255, 255, 255), bool bold = true) {
        box.pos = pos;
        box.size = size;
        this->text = text;
        this->fontSize = fontSize;
        this->color = color;
        this->bold = bold;
    }

    void draw(const DrawArgs &args) override {
        nvgFontSize(args.vg, fontSize);
        nvgFontFaceId(args.vg, APP->window->uiFont->handle);
        nvgTextAlign(args.vg, NVG_ALIGN_CENTER | NVG_ALIGN_MIDDLE);
        nvgFillColor(args.vg, color);

        if (bold) {
            float offset = 0.3f;
            nvgText(args.vg, box.size.x / 2.f - offset, box.size.y / 2.f, text.c_str(), NULL);
            nvgText(args.vg, box.size.x / 2.f + offset, box.size.y / 2.f, text.c_str(), NULL);
            nvgText(args.vg, box.size.x / 2.f, box.size.y / 2.f - offset, text.c_str(), NULL);
            nvgText(args.vg, box.size.x / 2.f, box.size.y / 2.f + offset, text.c_str(), NULL);
        }
        nvgText(args.vg, box.size.x / 2.f, box.size.y / 2.f, text.c_str(), NULL);
    }
};

struct NumberWithBorder : TransparentWidget {
    std::string text;
    float fontSize;
    NVGcolor textColor;
    NVGcolor borderColor;

    NumberWithBorder(Vec pos, Vec size, std::string text, float fontSize = 64.f,
                     NVGcolor textColor = nvgRGB(255, 255, 255), NVGcolor borderColor = nvgRGB(0, 0, 0)) {
        box.pos = pos;
        box.size = size;
        this->text = text;
        this->fontSize = fontSize;
        this->textColor = textColor;
        this->borderColor = borderColor;
    }

    void draw(const DrawArgs &args) override {
        nvgFontSize(args.vg, fontSize);
        nvgFontFaceId(args.vg, APP->window->uiFont->handle);
        nvgTextAlign(args.vg, NVG_ALIGN_CENTER | NVG_ALIGN_MIDDLE);

        // Draw black border (outline)
        nvgFillColor(args.vg, borderColor);
        float borderOffset = 1.5f;
        for (int x = -1; x <= 1; x++) {
            for (int y = -1; y <= 1; y++) {
                if (x == 0 && y == 0) continue;
                nvgText(args.vg, box.size.x / 2.f + x * borderOffset, box.size.y / 2.f + y * borderOffset, text.c_str(), NULL);
            }
        }

        // Draw white text on top
        nvgFillColor(args.vg, textColor);
        nvgText(args.vg, box.size.x / 2.f, box.size.y / 2.f, text.c_str(), NULL);
    }
};

struct WhiteBackgroundBox : Widget {
    WhiteBackgroundBox(Vec pos, Vec size) {
        box.pos = pos;
        box.size = size;
    }

    void draw(const DrawArgs &args) override {
        nvgBeginPath(args.vg);
        nvgRect(args.vg, 0, 0, box.size.x, box.size.y);
        nvgFillColor(args.vg, nvgRGB(255, 255, 255));
        nvgFill(args.vg);

        nvgStrokeWidth(args.vg, 1.0f);
        nvgStrokeColor(args.vg, nvgRGBA(200, 200, 200, 255));
        nvgStroke(args.vg);
    }
};

// ===== Custom Knobs =====

// Custom Parameter Quantity for wave shape display
struct WaveShapeParamQuantity : ParamQuantity {
    std::string getDisplayValueString() override {
        float value = getValue();
        if (value <= 0.1f) {
            return "Sine";
        } else if (value <= 0.2f) {
            return "Sine→Triangle";
        } else if (value <= 0.3f) {
            return "Triangle";
        } else if (value <= 0.4f) {
            return "Triangle→Saw";
        } else if (value <= 0.5f) {
            return "Saw";
        } else if (value <= 0.6f) {
            return "Saw→Pulse";
        } else {
            // Pulse width from 98% to 1%
            float pw = 0.98f - (value - 0.6f) * 2.425f; // Maps 0.6-1.0 to 0.98-0.01
            return string::f("Pulse (PW: %.0f%%)", pw * 100.f);
        }
    }
};

// Custom Parameter Quantities for frequency display
struct ModFreqParamQuantity : ParamQuantity {
    float getDisplayValue() override {
        float value = getValue();
        const float kModFreqKnobMin = 0.001f;
        const float kModFreqKnobMax = 6000.0f;

        // Exponential mapping: knob 0 = min freq, knob 1 = max freq
        float freq = kModFreqKnobMin * std::pow(kModFreqKnobMax / kModFreqKnobMin, value);
        return freq;
    }

    void setDisplayValue(float displayValue) override {
        // Convert frequency back to knob position
        const float kModFreqKnobMin = 0.001f;
        const float kModFreqKnobMax = 6000.0f;

        // Clamp to valid range
        displayValue = clamp(displayValue, kModFreqKnobMin, kModFreqKnobMax);

        // Reverse the exponential mapping
        float value = std::log(displayValue / kModFreqKnobMin) / std::log(kModFreqKnobMax / kModFreqKnobMin);
        setValue(value);
    }

    std::string getDisplayValueString() override {
        float freq = getDisplayValue();
        if (freq < 1.f) {
            return string::f("%.3f Hz", freq);
        } else if (freq < 10.f) {
            return string::f("%.2f Hz", freq);
        } else if (freq < 100.f) {
            return string::f("%.1f Hz", freq);
        } else if (freq < 1000.f) {
            return string::f("%.0f Hz", freq);
        } else {
            return string::f("%.2f kHz", freq / 1000.f);
        }
    }

    std::string getUnit() override {
        return "";
    }
};

struct DecayParamQuantity : ParamQuantity {
    std::string getDisplayValueString() override {
        float value = getValue();
        float decayTime;

        if (value >= 1.f) {
            // Maximum = drone mode
            return "Drone";
        } else if (value <= 0.5f) {
            // First 50%: 0-0.3 seconds
            decayTime = value * 0.6f;
        } else {
            // Last 50%: 0.3-3 seconds
            decayTime = 0.3f + (value - 0.5f) * 5.4f;
        }

        if (decayTime < 1.f) {
            return string::f("%.2f s", decayTime);
        } else {
            return string::f("%.1f s", decayTime);
        }
    }
};

struct FinalFreqParamQuantity : ParamQuantity {
    float getDisplayValue() override {
        float value = getValue();
        const float kFinalFreqKnobMin = 20.0f;
        const float kFinalFreqKnobMax = 8000.0f;

        // Exponential mapping: knob 0 = min freq, knob 1 = max freq
        float freq = kFinalFreqKnobMin * std::pow(kFinalFreqKnobMax / kFinalFreqKnobMin, value);
        return freq;
    }

    void setDisplayValue(float displayValue) override {
        // Convert frequency back to knob position
        const float kFinalFreqKnobMin = 20.0f;
        const float kFinalFreqKnobMax = 8000.0f;

        // Clamp to valid range
        displayValue = clamp(displayValue, kFinalFreqKnobMin, kFinalFreqKnobMax);

        // Reverse the exponential mapping
        float value = std::log(displayValue / kFinalFreqKnobMin) / std::log(kFinalFreqKnobMax / kFinalFreqKnobMin);
        setValue(value);
    }

    std::string getDisplayValueString() override {
        float freq = getDisplayValue();
        if (freq < 100.f) {
            return string::f("%.1f Hz", freq);
        } else if (freq < 1000.f) {
            return string::f("%.0f Hz", freq);
        } else {
            return string::f("%.2f kHz", freq / 1000.f);
        }
    }

    std::string getUnit() override {
        return "";
    }
};

struct LargeWhiteKnob : ParamWidget {
    bool isDragging = false;

    LargeWhiteKnob() {
        box.size = Vec(37, 37);
    }

    float getDisplayAngle() {
        ParamQuantity* pq = getParamQuantity();
        if (!pq) return 0.0f;
        float normalizedValue = pq->getScaledValue();
        return rescale(normalizedValue, 0.0f, 1.0f, -0.75f * M_PI, 0.75f * M_PI);
    }

    void draw(const DrawArgs& args) override {
        float radius = box.size.x / 2.0f;
        float angle = getDisplayAngle();

        // 外圈深灰色
        nvgBeginPath(args.vg);
        nvgCircle(args.vg, radius, radius, radius - 1);
        nvgFillColor(args.vg, nvgRGB(30, 30, 30));
        nvgFill(args.vg);

        // 外圈邊框
        nvgBeginPath(args.vg);
        nvgCircle(args.vg, radius, radius, radius - 1);
        nvgStrokeWidth(args.vg, 1.0f);
        nvgStrokeColor(args.vg, nvgRGB(100, 100, 100));
        nvgStroke(args.vg);

        // 白色內圈
        nvgBeginPath(args.vg);
        nvgCircle(args.vg, radius, radius, radius - 4);
        nvgFillColor(args.vg, nvgRGB(255, 255, 255));
        nvgFill(args.vg);

        // 粉紅色指引線
        float indicatorLength = radius - 8;
        float lineX = radius + indicatorLength * std::sin(angle);
        float lineY = radius - indicatorLength * std::cos(angle);

        nvgBeginPath(args.vg);
        nvgMoveTo(args.vg, radius, radius);
        nvgLineTo(args.vg, lineX, lineY);
        nvgStrokeWidth(args.vg, 2.0f);
        nvgStrokeColor(args.vg, nvgRGB(255, 133, 133));
        nvgStroke(args.vg);

        // 粉紅色指引點
        nvgBeginPath(args.vg);
        nvgCircle(args.vg, lineX, lineY, 2.0f);
        nvgFillColor(args.vg, nvgRGB(255, 133, 133));
        nvgFill(args.vg);
    }

    void onButton(const event::Button& e) override {
        if (e.action == GLFW_PRESS && e.button == GLFW_MOUSE_BUTTON_LEFT) {
            isDragging = true;
            e.consume(this);
        }
        ParamWidget::onButton(e);
    }

    void onDragMove(const event::DragMove& e) override {
        if (isDragging) {
            ParamQuantity* pq = getParamQuantity();
            if (pq) {
                float range = pq->getMaxValue() - pq->getMinValue();
                float delta = (e.mouseDelta.x - e.mouseDelta.y) * range / 200.0f;
                pq->setValue(pq->getValue() + delta);
            }
        }
    }

    void onDragEnd(const event::DragEnd& e) override {
        isDragging = false;
    }
};

struct SmallWhiteKnob : ParamWidget {
    bool isDragging = false;

    SmallWhiteKnob() {
        box.size = Vec(23, 23);
    }

    float getDisplayAngle() {
        ParamQuantity* pq = getParamQuantity();
        if (!pq) return 0.0f;
        float normalizedValue = pq->getScaledValue();
        return rescale(normalizedValue, 0.0f, 1.0f, -0.75f * M_PI, 0.75f * M_PI);
    }

    void draw(const DrawArgs& args) override {
        float radius = box.size.x / 2.0f;
        float angle = getDisplayAngle();

        // 外圈白色
        nvgBeginPath(args.vg);
        nvgCircle(args.vg, radius, radius, radius - 1);
        nvgFillColor(args.vg, nvgRGB(255, 255, 255));
        nvgFill(args.vg);

        // 外圈邊框 (黑色)
        nvgBeginPath(args.vg);
        nvgCircle(args.vg, radius, radius, radius - 1);
        nvgStrokeWidth(args.vg, 1.0f);
        nvgStrokeColor(args.vg, nvgRGB(0, 0, 0));
        nvgStroke(args.vg);

        // 內圈淺灰色
        nvgBeginPath(args.vg);
        nvgCircle(args.vg, radius, radius, radius - 3);
        nvgFillColor(args.vg, nvgRGB(240, 240, 240));
        nvgFill(args.vg);

        // 粉紅色指引線
        float indicatorLength = radius - 6;
        float lineX = radius + indicatorLength * std::sin(angle);
        float lineY = radius - indicatorLength * std::cos(angle);

        nvgBeginPath(args.vg);
        nvgMoveTo(args.vg, radius, radius);
        nvgLineTo(args.vg, lineX, lineY);
        nvgStrokeWidth(args.vg, 1.5f);
        nvgStrokeColor(args.vg, nvgRGB(255, 133, 133));
        nvgStroke(args.vg);

        // 粉紅色指引點
        nvgBeginPath(args.vg);
        nvgCircle(args.vg, lineX, lineY, 1.5f);
        nvgFillColor(args.vg, nvgRGB(255, 133, 133));
        nvgFill(args.vg);
    }

    void onButton(const event::Button& e) override {
        if (e.action == GLFW_PRESS && e.button == GLFW_MOUSE_BUTTON_LEFT) {
            isDragging = true;
            e.consume(this);
        }
        ParamWidget::onButton(e);
    }

    void onDragMove(const event::DragMove& e) override {
        if (isDragging) {
            ParamQuantity* pq = getParamQuantity();
            if (pq) {
                float range = pq->maxValue - pq->minValue;
                float delta = 0.00225f * -e.mouseDelta.y * range;
                pq->setValue(pq->getValue() + delta);
            }
        }
    }

    void onDragEnd(const event::DragEnd& e) override {
        isDragging = false;
    }
};

struct SmallGrayKnob : ParamWidget {
    bool isDragging = false;

    SmallGrayKnob() {
        box.size = Vec(28, 28);
    }

    float getDisplayAngle() {
        ParamQuantity* pq = getParamQuantity();
        if (!pq) return 0.0f;
        float normalizedValue = pq->getScaledValue();
        return rescale(normalizedValue, 0.0f, 1.0f, -0.75f * M_PI, 0.75f * M_PI);
    }

    void draw(const DrawArgs& args) override {
        float radius = box.size.x / 2.0f;
        float angle = getDisplayAngle();

        // 外圈深灰色
        nvgBeginPath(args.vg);
        nvgCircle(args.vg, radius, radius, radius - 1);
        nvgFillColor(args.vg, nvgRGB(30, 30, 30));
        nvgFill(args.vg);

        // 外圈邊框
        nvgBeginPath(args.vg);
        nvgCircle(args.vg, radius, radius, radius - 1);
        nvgStrokeWidth(args.vg, 1.0f);
        nvgStrokeColor(args.vg, nvgRGB(100, 100, 100));
        nvgStroke(args.vg);

        // 白色內圈
        nvgBeginPath(args.vg);
        nvgCircle(args.vg, radius, radius, radius - 3);
        nvgFillColor(args.vg, nvgRGB(255, 255, 255));
        nvgFill(args.vg);

        // 粉紅色指引線
        float indicatorLength = radius - 6;
        float lineX = radius + indicatorLength * std::sin(angle);
        float lineY = radius - indicatorLength * std::cos(angle);

        nvgBeginPath(args.vg);
        nvgMoveTo(args.vg, radius, radius);
        nvgLineTo(args.vg, lineX, lineY);
        nvgStrokeWidth(args.vg, 1.5f);
        nvgStrokeColor(args.vg, nvgRGB(255, 133, 133));
        nvgStroke(args.vg);

        // 粉紅色指引點
        nvgBeginPath(args.vg);
        nvgCircle(args.vg, lineX, lineY, 1.5f);
        nvgFillColor(args.vg, nvgRGB(255, 133, 133));
        nvgFill(args.vg);
    }

    void onButton(const event::Button& e) override {
        if (e.action == GLFW_PRESS && e.button == GLFW_MOUSE_BUTTON_LEFT) {
            isDragging = true;
            e.consume(this);
        }
        ParamWidget::onButton(e);
    }

    void onDragMove(const event::DragMove& e) override {
        if (isDragging) {
            ParamQuantity* pq = getParamQuantity();
            if (pq) {
                float range = pq->getMaxValue() - pq->getMinValue();
                float delta = (e.mouseDelta.x - e.mouseDelta.y) * range / 200.0f;
                pq->setValue(pq->getValue() + delta);
            }
        }
    }

    void onDragEnd(const event::DragEnd& e) override {
        isDragging = false;
    }
};

struct HiddenTimeKnob : ParamWidget {
    HiddenTimeKnob() {
        box.size = Vec(66, 38.5);
    }

    void draw(const DrawArgs& args) override {
        // Draw nothing - completely invisible
    }

    void onEnter(const event::Enter& e) override {
        glfwSetCursor(APP->window->win, glfwCreateStandardCursor(GLFW_VRESIZE_CURSOR));
        ParamWidget::onEnter(e);
    }

    void onLeave(const event::Leave& e) override {
        glfwSetCursor(APP->window->win, NULL);
        ParamWidget::onLeave(e);
    }

    void onDragMove(const event::DragMove& e) override {
        ParamQuantity* pq = getParamQuantity();
        if (!pq) return;

        float sensitivity = 0.003f; // Reduced sensitivity for better control
        float deltaValue = -e.mouseDelta.y * sensitivity * (pq->getMaxValue() - pq->getMinValue());
        float newValue = pq->getValue() + deltaValue;
        pq->setValue(newValue);
        e.consume(this);
    }
};

// Forward declaration
struct VisualDisplay;

// ===== Module Definition =====
struct NIGOQ : Module {
    enum ParamIds {
        MOD_FREQ,
        FINAL_FREQ,
        LPF_CUTOFF,
        ORDER,
        HARMONICS,
        MOD_WAVE,
        FM_AMT_ATTEN,
        FOLD_AMT_ATTEN,
        AM_AMT_ATTEN,
        MOD_FM_ATTEN,
        FINAL_FM_ATTEN,
        DECAY,
        BASS,
        FM_AMT,
        FOLD_AMT,
        AM_AMT,
        SYNC_MODE,
        SCOPE_TIME,
        TRIG_PARAM,
        NUM_PARAMS
    };

    enum InputIds {
        TRIG_IN,
        MOD_WAVE_CV,
        LPF_CUTOFF_CV,
        ORDER_CV,
        FM_AMT_CV,
        HARMONICS_CV,
        FOLD_AMT_CV,
        AM_AMT_CV,
        MOD_FM_IN,
        MOD_1VOCT,
        FINAL_FM_IN,
        FINAL_1VOCT,
        NUM_INPUTS
    };

    enum OutputIds {
        MOD_SIGNAL_OUT,
        FINAL_SINE_OUT,
        FINAL_FINAL_OUT,
        NUM_OUTPUTS
    };

    enum LightIds {
        TRIG_LIGHT,
        NUM_LIGHTS
    };

    // Scope display (exactly like Observer)
    struct ScopePoint {
        float min = INFINITY;
        float max = -INFINITY;
    };

    static constexpr int SCOPE_BUFFER_SIZE = 256; // Same as Observer
    ScopePoint finalBuffer[SCOPE_BUFFER_SIZE];
    ScopePoint modBuffer[SCOPE_BUFFER_SIZE];
    ScopePoint currentFinal;
    ScopePoint currentMod;
    int bufferIndex = 0;
    int frameIndex = 0;

    VisualDisplay* visualDisplay = nullptr;

    // Oscillators
    float modPhase = 0.f;
    float finalPhase = 0.f;
    float prevFinalPhase = 0.f;  // For sync detection (FINAL syncs MOD)

    // AD Envelope implementation from AD Generator
    enum EnvelopePhase {
        ENV_IDLE,
        ENV_ATTACK,
        ENV_DECAY
    };

    struct ADEnvelope {
        EnvelopePhase phase = ENV_IDLE;
        float phaseTime = 0.0f;
        float output = 0.0f;
        dsp::SchmittTrigger trigger;

        void reset() {
            phase = ENV_IDLE;
            phaseTime = 0.0f;
            output = 0.0f;
            trigger.reset();
        }

        // Apply curve function from AD Generator
        float applyCurve(float x, float curvature) {
            x = clamp(x, 0.0f, 1.0f);

            if (curvature == 0.0f) {
                return x;
            }

            float k = curvature;
            float abs_x = std::abs(x);
            float denominator = k - 2.0f * k * abs_x + 1.0f;

            if (std::abs(denominator) < 1e-6f) {
                return x;
            }

            return (x - k * x) / denominator;
        }

        float process(float sampleTime, float triggerVoltage, float attackTime, float decayTime, float curveParam = 0.5f) {

            // Trigger detection with retrigger capability
            if (trigger.process(triggerVoltage)) {
                phase = ENV_ATTACK;
                phaseTime = 0.0f;
            }

            switch (phase) {
                case ENV_IDLE:
                    output = 0.0f;
                    break;

                case ENV_ATTACK:
                    phaseTime += sampleTime;
                    if (phaseTime >= attackTime) {
                        phase = ENV_DECAY;
                        phaseTime = 0.0f;
                        output = 1.0f;
                    } else {
                        float t = phaseTime / attackTime;
                        output = applyCurve(t, curveParam);  // Apply curve to attack
                    }
                    break;

                case ENV_DECAY:
                    phaseTime += sampleTime;
                    if (decayTime <= 0.0f) {
                        // Instant decay
                        output = 0.0f;
                        phase = ENV_IDLE;
                        phaseTime = 0.0f;
                    } else if (phaseTime >= decayTime) {
                        output = 0.0f;
                        phase = ENV_IDLE;
                        phaseTime = 0.0f;
                    } else {
                        float t = phaseTime / decayTime;
                        output = 1.0f - applyCurve(t, curveParam);  // Apply curve to decay
                    }
                    break;
            }

            return clamp(output, 0.0f, 1.0f);
        }
    };

    ADEnvelope modEnvelope;
    ADEnvelope finalEnvelope;

    // Attack time setting (in seconds)
    float attackTime = 0.01f;  // Default 10ms for punchy bass

    // Oversampling using simple averaging approach
    int oversampleRate = 1;
    int oversampleQuality = 1; // 0=low quality, 1=medium, 2=high quality

    // Scope trigger detection (like Observer)
    dsp::SchmittTrigger scopeTriggers[16];

    // DC blocking for Order function
    float orderDCBlock = 0.0f;
    float orderDCBlock2 = 0.0f;

    // Smooth randomization variables
    float randomizeGlideTime = 1.0f;  // Default 1 second glide time
    float randomAmount = 1.0f;  // Default full range randomization (1.0 = 100%)
    bool smoothRandomizeActive = false;
    float smoothRandomizeTimer = 0.0f;
    static constexpr int PARAMS_LEN = NUM_PARAMS;
    float paramSourceValues[NUM_PARAMS] = {};
    float paramTargetValues[NUM_PARAMS] = {};

    // Simple one-pole lowpass filter (more musical than Butterworth)
    struct SimpleLP {
        float z1 = 0.0f;
        float cutoff = 1.0f;
        float sampleRate = 44100.0f;

        void setSampleRate(float sr) {
            sampleRate = sr;
        }

        void setCutoff(float cutoffFreq) {
            // One-pole lowpass coefficient
            float fc = cutoffFreq / sampleRate;
            fc = clamp(fc, 0.0001f, 0.4999f);

            // Warped cutoff for more accurate frequency response
            float wc = std::tan(M_PI * fc);
            cutoff = wc / (1.0f + wc);
        }

        float process(float input) {
            // One-pole lowpass: y = x * cutoff + y * (1 - cutoff)
            z1 = input * cutoff + z1 * (1.0f - cutoff);
            return z1;
        }

        void reset() {
            z1 = 0.0f;
        }
    };

    // Cascade two one-pole filters for 12dB/oct slope
    struct TwoPoleLP {
        SimpleLP lp1, lp2;
        float resonance = 0.0f;

        void setSampleRate(float sr) {
            lp1.setSampleRate(sr);
            lp2.setSampleRate(sr);
        }

        void setCutoff(float cutoffFreq) {
            lp1.setCutoff(cutoffFreq);
            lp2.setCutoff(cutoffFreq);
        }

        float process(float input) {
            // Add resonance feedback
            float feedback = lp2.z1 * resonance * 0.4f;
            float stage1 = lp1.process(input - feedback);
            float output = lp2.process(stage1);
            return output;
        }

        void reset() {
            lp1.reset();
            lp2.reset();
        }
    };

    TwoPoleLP lpFilter;

    // Parameter smoothing to prevent zipper noise
    struct SmoothedParam {
        float value = 0.f;
        float target = 0.f;

        void setTarget(float newTarget) {
            target = newTarget;
        }

        float process() {
            // Exponential smoothing with ~5ms time constant at 44.1kHz
            const float alpha = 0.995f;
            value = value * alpha + target * (1.f - alpha);
            return value;
        }

        void reset(float initValue) {
            value = initValue;
            target = initValue;
        }
    };

    // Smoothed parameter values
    SmoothedParam smoothedModFreq;
    SmoothedParam smoothedFinalFreq;
    SmoothedParam smoothedLpfCutoff;
    SmoothedParam smoothedOrder;
    SmoothedParam smoothedHarmonics;
    SmoothedParam smoothedWaveMorph;
    SmoothedParam smoothedFmAmt;
    SmoothedParam smoothedFoldAmt;
    SmoothedParam smoothedSymAmt;
    SmoothedParam smoothedBass;

    // Wavefolding function with smooth, rounded folds
    float wavefold(float input, float amount) {
        // amount: 0 = no folding, 1 = max folding
        if (amount <= 0.0f) return input;

        // Progressive gain for more folds (up to 12x)
        float gain = 1.0f + amount * 11.0f;
        float amplified = input * gain;

        // Use cosine instead of sine for rounder peaks
        float folded = std::cos(amplified * M_PI * 0.25f);

        // Add harmonics with smoother blending
        if (amount > 0.35f) {
            float fold2 = std::cos(amplified * M_PI * 0.5f);
            float blend = (amount - 0.35f) / 0.65f;
            blend = blend * blend; // Square for smoother transition
            folded = folded * (1.0f - blend * 0.3f) + fold2 * blend * 0.3f;
        }

        if (amount > 0.6f) {
            float fold3 = std::cos(amplified * M_PI * 0.75f);
            float blend = (amount - 0.6f) / 0.4f;
            blend = blend * blend; // Square for smoother transition
            folded = folded * (1.0f - blend * 0.2f) + fold3 * blend * 0.2f;
        }

        if (amount > 0.8f) {
            float fold4 = std::cos(amplified * M_PI);
            float blend = (amount - 0.8f) / 0.2f;
            blend = blend * blend; // Square for smoother transition
            folded = folded * (1.0f - blend * 0.1f) + fold4 * blend * 0.1f;
        }

        // Double tanh for extra smoothness
        float output = std::tanh(folded);
        output = std::tanh(output * 1.5f);

        // Smooth crossfade
        float wetness = amount * amount; // Square for smoother response
        return input * (1.0f - wetness * 0.8f) + output * (wetness * 0.8f + 0.2f);
    }

    // Symmetry function - unipolar, creates positive asymmetry only
    float asymmetricRectifier(float input, float amount) {
        // amount: 0 = no rectification (original signal)
        //         0.5 = half rectification (negative values reduced by 50%)
        //         1.0 = full half-wave rectification (negative values become 0)

        float output = input;

        if (input < 0.0f) {
            // For negative values, apply progressive attenuation
            // At amount=0: no change
            // At amount=0.5: multiply by 0.5
            // At amount=1.0: multiply by 0 (full rectification)
            output = input * (1.0f - amount);
        }
        // Positive values pass through unchanged

        // DC blocking for asymmetric waveforms
        // More aggressive DC blocking as rectification increases
        float dcBlockCutoff = 0.995f - amount * 0.01f; // Faster response for more rectification
        orderDCBlock = orderDCBlock * dcBlockCutoff + output * (1.0f - dcBlockCutoff);
        output = output - orderDCBlock;

        // Normalize output level to compensate for energy loss
        // As we remove negative parts, boost the signal to maintain perceived loudness
        float compensation = 1.0f + amount * 0.5f; // Up to 1.5x boost at full rectification
        output *= compensation;

        // Soft clipping to prevent excessive peaks
        output = std::tanh(output * 0.8f) * 1.25f;

        return output;
    }

    // PolyBLEP function for anti-aliasing
    float polyBLEP(float t, float dt) {
        // t = phase position, dt = phase increment (frequency)
        if (t < dt) {
            t /= dt;
            return t + t - t * t - 1.0f;
        }
        else if (t > 1.0f - dt) {
            t = (t - 1.0f) / dt;
            return t * t + t + t + 1.0f;
        }
        return 0.0f;
    }

    // Helper function to generate morphing waveforms with PolyBLEP anti-aliasing
    float generateMorphingWave(float phase, float morphParam, float phaseInc = 0.01f) {
        // morphParam:
        // 0.0-0.2 = sine to triangle
        // 0.2-0.4 = triangle to saw
        // 0.4-0.6 = saw to pulse (98%)
        // 0.6-1.0 = pulse with variable width (98% to 1%)
        // Returns bipolar signal (-1 to 1)

        float output = 0.f;

        if (morphParam <= 0.2f) {
            // Morph between sine and triangle
            float blend = morphParam * 5.f; // 0 to 1
            float sine = std::sin(2.f * M_PI * phase);
            float triangle = 2.f * std::abs(2.f * (phase - std::floor(phase + 0.5f))) - 1.f;
            output = sine * (1.f - blend) + triangle * blend;
        }
        else if (morphParam <= 0.4f) {
            // Morph between triangle and saw (with PolyBLEP)
            float blend = (morphParam - 0.2f) * 5.f; // 0 to 1
            float triangle = 2.f * std::abs(2.f * (phase - std::floor(phase + 0.5f))) - 1.f;

            // Band-limited saw with PolyBLEP (falling/ramp-down)
            float saw = 1.f - 2.f * phase;  // Reversed: starts at +1, falls to -1
            saw += polyBLEP(phase, phaseInc);  // Add instead of subtract for falling saw

            output = triangle * (1.f - blend) + saw * blend;
        }
        else if (morphParam <= 0.6f) {
            // Morph between saw and pulse (with PolyBLEP)
            float blend = (morphParam - 0.4f) * 5.f; // 0 to 1

            // Band-limited saw (falling/ramp-down)
            float saw = 1.f - 2.f * phase;  // Reversed: starts at +1, falls to -1
            saw += polyBLEP(phase, phaseInc);  // Add instead of subtract for falling saw

            // Band-limited pulse (98% duty)
            float pulseWidth = 0.98f;
            float pulse = phase < pulseWidth ? 1.f : -1.f;
            pulse += polyBLEP(phase, phaseInc);
            pulse -= polyBLEP(std::fmod(phase + (1.f - pulseWidth), 1.f), phaseInc);

            output = saw * (1.f - blend) + pulse * blend;
        }
        else {
            // Variable pulse width with PolyBLEP anti-aliasing
            float pwParam = (morphParam - 0.6f) / 0.4f; // 0 to 1
            float pulseWidth = 0.98f - pwParam * 0.97f; // 98% down to 1%

            // Band-limited pulse
            float pulse = phase < pulseWidth ? 1.f : -1.f;
            pulse += polyBLEP(phase, phaseInc);
            pulse -= polyBLEP(std::fmod(phase + (1.f - pulseWidth), 1.f), phaseInc);

            output = pulse;
        }

        return output;
    }

    NIGOQ() {
        config(NUM_PARAMS, NUM_INPUTS, NUM_OUTPUTS, NUM_LIGHTS);

        // Configure parameters with Bass preset as default
        // Bass preset: Rich low-end with controlled harmonics
        configParam<ModFreqParamQuantity>(MOD_FREQ, 0.f, 1.f, 0.25f, "Modulation Frequency");  // ~8Hz for subtle movement
        configParam<FinalFreqParamQuantity>(FINAL_FREQ, 0.f, 1.f, 0.3f, "Final Frequency");  // ~110Hz (A2 bass range)
        configParam(LPF_CUTOFF, 0.f, 1.f, 0.35f, "LPF Cutoff", " Hz");  // ~800Hz for warm bass
        configParam(ORDER, 0.f, 1.f, 0.15f, "Rectify Amount", "%", 0.f, 100.f);  // Asymmetric rectification
        configParam(HARMONICS, 0.f, 1.f, 0.25f, "Wavefolding", "%", 0.f, 100.f);  // Moderate fold for harmonics
        configParam<WaveShapeParamQuantity>(MOD_WAVE, 0.f, 1.f, 0.15f, "Modulation Wave Shape");  // Between sine and triangle
        configParam(FM_AMT_ATTEN, 0.f, 1.f, 0.7f, "FM CV Attenuator", "%", 0.f, 100.f);  // Moderate CV response
        configParam(FOLD_AMT_ATTEN, 0.f, 1.f, 0.7f, "TM CV Attenuator", "%", 0.f, 100.f);  // Moderate CV response
        configParam(AM_AMT_ATTEN, 0.f, 1.f, 0.7f, "RECT CV Attenuator", "%", 0.f, 100.f);  // Moderate CV response
        configParam(MOD_FM_ATTEN, 0.f, 1.f, 0.f, "Mod FM Attenuator", "%", 0.f, 100.f);
        configParam(FINAL_FM_ATTEN, 0.f, 1.f, 0.f, "Final FM Attenuator", "%", 0.f, 100.f);
        configParam<DecayParamQuantity>(DECAY, 0.f, 1.f, 0.73f, "Decay Time");  // ~1.3s for sustained bass
        configParam(BASS, 0.f, 1.f, 0.3f, "Bass/Sine Mix", "%", 0.f, 100.f);  // 30% sine for fundamental boost
        configParam(FM_AMT, 0.f, 1.f, 0.05f, "Linear FM Index", "", 0.f, 4.f);  // Subtle FM for texture
        configParam(FOLD_AMT, 0.f, 1.f, 0.5f, "TM Amount", "%", 0.f, 100.f);  // 50% timbre modulation for richer harmonics
        configParam(AM_AMT, 0.f, 1.f, 0.2f, "RECT Mod Amount", "%", 0.f, 100.f);  // Rectify modulation for wave shaping
        configSwitch(SYNC_MODE, 0.f, 2.f, 0.f, "Sync Mode", {"Off", "Soft", "Hard"});  // Sync off for bass
        // Time parameter (exactly like Observer)
        const float maxTime = -std::log2(5e1f);
        const float minTime = -std::log2(5e-3f);
        const float defaultTime = -std::log2(5e-1f);
        configParam(SCOPE_TIME, maxTime, minTime, defaultTime, "Time", " ms/screen", 1 / 2.f, 1000);

        // Trigger parameter (like Observer)
        configSwitch(TRIG_PARAM, 0.f, 1.f, 1.f, "Trigger", {"Enabled", "Disabled"});
        configLight(TRIG_LIGHT, "Trigger Light");

        // Configure inputs
        configInput(TRIG_IN, "Trigger");
        configInput(MOD_WAVE_CV, "Modulation Wave CV");
        configInput(LPF_CUTOFF_CV, "LPF Cutoff CV");
        configInput(ORDER_CV, "Rectify CV");
        configInput(FM_AMT_CV, "FM Amount CV");
        configInput(HARMONICS_CV, "Harmonics CV");
        configInput(FOLD_AMT_CV, "Fold Amount CV");
        configInput(AM_AMT_CV, "RECT Mod Amount CV");
        configInput(MOD_FM_IN, "Modulation FM");
        configInput(MOD_1VOCT, "Modulation 1V/Oct");
        configInput(FINAL_FM_IN, "Final FM");
        configInput(FINAL_1VOCT, "Final 1V/Oct");

        // Configure outputs
        configOutput(MOD_SIGNAL_OUT, "Modulation Signal");
        configOutput(FINAL_SINE_OUT, "Final Sine");
        configOutput(FINAL_FINAL_OUT, "Final Output");

        // Initialize oversampling filters
        setupOversamplingFilters();

        // Initialize smoothed parameters to default values
        smoothedModFreq.reset(params[MOD_FREQ].getValue());
        smoothedFinalFreq.reset(params[FINAL_FREQ].getValue());
        smoothedLpfCutoff.reset(params[LPF_CUTOFF].getValue());
        smoothedOrder.reset(params[ORDER].getValue());
        smoothedHarmonics.reset(params[HARMONICS].getValue());
        smoothedWaveMorph.reset(params[MOD_WAVE].getValue());
        smoothedFmAmt.reset(params[FM_AMT].getValue());
        smoothedFoldAmt.reset(params[FOLD_AMT].getValue());
        smoothedSymAmt.reset(params[AM_AMT].getValue());
        smoothedBass.reset(params[BASS].getValue());
    }

    void setupOversamplingFilters() {
        // Don't need to setup filters here since we'll use simple averaging
        // The IIR filters were causing issues, so we'll use a simpler approach

        // Setup lowpass filter with current sample rate
        lpFilter.setSampleRate(APP->engine->getSampleRate());
        lpFilter.setCutoff(8000.0f);  // Default cutoff at 8kHz
        lpFilter.reset();
    }

    void onSampleRateChange() override {
        // Update oversampling filters for new sample rate
        setupOversamplingFilters();

        // Update lowpass filter sample rate
        lpFilter.setSampleRate(APP->engine->getSampleRate());
    }

    void onRandomize(const RandomizeEvent& e) override {
        // Store current parameter values as source
        for (int i = 0; i < PARAMS_LEN; i++) {
            paramSourceValues[i] = params[i].getValue();
        }

        // Generate random target values (excluding FINAL_FREQ to keep pitch stable)
        for (int i = 0; i < PARAMS_LEN; i++) {
            if (i != FINAL_FREQ) {  // Skip FINAL_FREQ to maintain pitch
                ParamQuantity* pq = paramQuantities[i];
                if (pq && pq->isBounded()) {
                    float currentValue = paramSourceValues[i];
                    float minValue = pq->getMinValue();
                    float maxValue = pq->getMaxValue();
                    float fullRange = maxValue - minValue;
                    float randomRange = fullRange * randomAmount;

                    // Center the random range around current value, but clamp to parameter bounds
                    float rangeMin = clamp(currentValue - randomRange * 0.5f, minValue, maxValue);
                    float rangeMax = clamp(currentValue + randomRange * 0.5f, minValue, maxValue);

                    // If the clamped range is smaller than desired, expand it within bounds
                    if (rangeMax - rangeMin < randomRange) {
                        float deficit = randomRange - (rangeMax - rangeMin);
                        if (rangeMin > minValue) {
                            rangeMin = clamp(rangeMin - deficit * 0.5f, minValue, rangeMin);
                        }
                        if (rangeMax < maxValue) {
                            rangeMax = clamp(rangeMax + deficit * 0.5f, rangeMax, maxValue);
                        }
                    }

                    paramTargetValues[i] = random::uniform() * (rangeMax - rangeMin) + rangeMin;
                } else {
                    paramTargetValues[i] = paramSourceValues[i];
                }
            } else {
                paramTargetValues[i] = paramSourceValues[i];  // Keep FINAL_FREQ unchanged
            }
        }

        // Start smooth randomization
        smoothRandomizeActive = true;
        smoothRandomizeTimer = 0.0f;

        // Don't call Module::onRandomize(e) as we handle everything ourselves
    }

    json_t* dataToJson() override {
        json_t* rootJ = json_object();
        json_object_set_new(rootJ, "oversampleRate", json_integer(oversampleRate));
        json_object_set_new(rootJ, "oversampleQuality", json_integer(oversampleQuality));
        json_object_set_new(rootJ, "attackTime", json_real(attackTime));
        // Save randomization settings
        json_object_set_new(rootJ, "randomizeGlideTime", json_real(randomizeGlideTime));
        json_object_set_new(rootJ, "randomAmount", json_real(randomAmount));
        return rootJ;
    }

    void dataFromJson(json_t* rootJ) override {
        json_t* oversampleRateJ = json_object_get(rootJ, "oversampleRate");
        if (oversampleRateJ) {
            oversampleRate = json_integer_value(oversampleRateJ);
            oversampleRate = clamp(oversampleRate, 1, 32);
        }

        json_t* oversampleQualityJ = json_object_get(rootJ, "oversampleQuality");
        if (oversampleQualityJ) {
            oversampleQuality = json_integer_value(oversampleQualityJ);
            oversampleQuality = clamp(oversampleQuality, 0, 2);
        }

        // Update oversampling filters with loaded settings
        setupOversamplingFilters();

        json_t* attackTimeJ = json_object_get(rootJ, "attackTime");
        if (attackTimeJ) {
            attackTime = json_real_value(attackTimeJ);
            attackTime = clamp(attackTime, 0.0001f, 0.1f);  // Clamp to valid range
        }

        // Load randomization settings
        json_t* randomizeGlideTimeJ = json_object_get(rootJ, "randomizeGlideTime");
        if (randomizeGlideTimeJ)
            randomizeGlideTime = json_real_value(randomizeGlideTimeJ);

        json_t* randomAmountJ = json_object_get(rootJ, "randomAmount");
        if (randomAmountJ)
            randomAmount = json_real_value(randomAmountJ);
    }



    void process(const ProcessArgs& args) override {
        // Handle smooth randomization
        if (smoothRandomizeActive) {
            smoothRandomizeTimer += args.sampleTime;
            float progress = smoothRandomizeTimer / randomizeGlideTime;

            if (progress >= 1.0f) {
                // Randomization complete
                progress = 1.0f;
                smoothRandomizeActive = false;
            }

            // Smooth interpolation using sine curve for more natural feel
            float smoothProgress = (1.0f - cosf(progress * M_PI)) * 0.5f;

            // Apply interpolated values to parameters
            for (int i = 0; i < PARAMS_LEN; i++) {
                if (i != FINAL_FREQ) {  // Skip FINAL_FREQ
                    float currentValue = paramSourceValues[i] + (paramTargetValues[i] - paramSourceValues[i]) * smoothProgress;
                    params[i].setValue(currentValue);
                }
            }
        }

        // Update smoothed parameter targets
        smoothedModFreq.setTarget(params[MOD_FREQ].getValue());
        smoothedFinalFreq.setTarget(params[FINAL_FREQ].getValue());
        smoothedLpfCutoff.setTarget(params[LPF_CUTOFF].getValue());
        smoothedOrder.setTarget(params[ORDER].getValue());
        smoothedHarmonics.setTarget(params[HARMONICS].getValue());
        smoothedWaveMorph.setTarget(params[MOD_WAVE].getValue());
        smoothedFmAmt.setTarget(params[FM_AMT].getValue());
        smoothedFoldAmt.setTarget(params[FOLD_AMT].getValue());
        smoothedSymAmt.setTarget(params[AM_AMT].getValue());
        smoothedBass.setTarget(params[BASS].getValue());

        // Process smoothed parameters
        float modFreqKnob = smoothedModFreq.process();
        const float kModFreqKnobMin = 0.001f;
        const float kModFreqKnobMax = 6000.0f;
        float modFreq = kModFreqKnobMin * std::pow(kModFreqKnobMax / kModFreqKnobMin, modFreqKnob);

        // Apply 1V/Oct CV if connected
        if (inputs[MOD_1VOCT].isConnected()) {
            float voct = inputs[MOD_1VOCT].getVoltage();
            modFreq *= std::pow(2.f, voct);
        }

        // Apply FM if connected
        if (inputs[MOD_FM_IN].isConnected()) {
            float fmAmount = params[MOD_FM_ATTEN].getValue();
            float fmSignal = inputs[MOD_FM_IN].getVoltage() / 5.f; // Normalize to ±1
            modFreq *= (1.f + fmSignal * fmAmount);
        }

        // Clamp frequency to valid range
        modFreq = clamp(modFreq, 0.001f, args.sampleRate * oversampleRate / 2.f);

        // Get wave morph parameter
        float waveMorph = smoothedWaveMorph.process();

        // Apply wave CV if connected
        if (inputs[MOD_WAVE_CV].isConnected()) {
            float waveCV = inputs[MOD_WAVE_CV].getVoltage() / 10.f; // Normalize 0-10V to 0-1
            waveMorph = clamp(waveMorph + waveCV, 0.f, 1.f);
        }

        float modOutput = 0.f;

        // Track previous FINAL phase for sync detection (FINAL syncs MOD)
        prevFinalPhase = finalPhase;

        if (oversampleRate > 1) {
            // Simple oversampling: generate at higher rate and average
            float deltaPhase = modFreq / (args.sampleRate * oversampleRate);
            float modSignal = 0.f;

            // Generate oversampled samples and accumulate
            for (int i = 0; i < oversampleRate; i++) {
                // Update phase
                modPhase += deltaPhase;
                if (modPhase >= 1.f) {
                    modPhase -= 1.f;
                }

                // Generate morphing waveform with PolyBLEP (bipolar -1 to 1)
                float sample = generateMorphingWave(modPhase, waveMorph, deltaPhase);

                // Simple box filter (averaging)
                modSignal += sample;
            }

            // Average the samples
            modSignal /= oversampleRate;

            // Convert to unipolar 0-10V output
            modOutput = (modSignal + 1.f) * 5.f; // Convert -1..1 to 0..10V
        } else {
            // Normal processing without oversampling
            float deltaPhase = modFreq * args.sampleTime;
            modPhase += deltaPhase;
            if (modPhase >= 1.f) {
                modPhase -= 1.f;
            }

            // Generate morphing waveform with PolyBLEP (bipolar -1 to 1)
            float modSignal = generateMorphingWave(modPhase, waveMorph, deltaPhase);

            // Convert to unipolar 0-10V output
            modOutput = (modSignal + 1.f) * 5.f; // Convert -1..1 to 0..10V
        }

        // Get decay parameter and process envelopes EARLY for modulation
        float decayParam = params[DECAY].getValue();
        float decayTime;
        if (decayParam <= 0.5f) {
            decayTime = decayParam * 0.6f;
        } else {
            decayTime = 0.3f + (decayParam - 0.5f) * 5.4f;
        }

        float triggerVoltage = inputs[TRIG_IN].isConnected() ? inputs[TRIG_IN].getVoltage() : 0.0f;
        float modVcaGain, finalVcaGain;

        if (decayTime >= 3.f) {
            modVcaGain = 1.f;
            finalVcaGain = 1.f;
            modEnvelope.reset();
            finalEnvelope.reset();
        } else {
            const float fixedCurve = -0.95f;
            modVcaGain = modEnvelope.process(args.sampleTime, triggerVoltage, attackTime, decayTime, fixedCurve);
            finalVcaGain = finalEnvelope.process(args.sampleTime, triggerVoltage, attackTime, decayTime, fixedCurve);
        }

        // Calculate modulation signal (post-VCA) for FM/TM/AM
        float modOutputWithVca = modOutput * modVcaGain;
        float modSignalForModulation = (modOutputWithVca - 5.f) / 5.f;  // Convert 0-10V back to -1 to 1

        // Get FINAL frequency from knob (exponential mapping done in ParamQuantity)
        float finalFreqKnob = smoothedFinalFreq.process();
        const float kFinalFreqKnobMin = 20.0f;
        const float kFinalFreqKnobMax = 8000.0f;
        float finalFreq = kFinalFreqKnobMin * std::pow(kFinalFreqKnobMax / kFinalFreqKnobMin, finalFreqKnob);

        // Apply 1V/Oct CV if connected
        if (inputs[FINAL_1VOCT].isConnected()) {
            float voct = inputs[FINAL_1VOCT].getVoltage();
            finalFreq *= std::pow(2.f, voct);
        }

        // Apply external Linear FM if connected (enhanced linear FM)
        if (inputs[FINAL_FM_IN].isConnected()) {
            float fmAmount = params[FINAL_FM_ATTEN].getValue();
            float fmSignal = inputs[FINAL_FM_IN].getVoltage() / 5.f; // Normalize to ±1
            // Enhanced FM: up to 10x frequency modulation for stronger effect
            finalFreq *= (1.f + fmSignal * fmAmount * 10.f);
        }

        // Apply internal Through-Zero Linear FM from Mod oscillator (post-VCA)
        float fmModAmount = smoothedFmAmt.process();  // Gray FM knob
        if (inputs[FM_AMT_CV].isConnected()) {
            float fmAttenuation = params[FM_AMT_ATTEN].getValue();  // White attenuator knob
            float fmCV = inputs[FM_AMT_CV].getVoltage() / 10.f;  // 0-10V to 0-1
            fmModAmount += fmCV * fmAttenuation;
            fmModAmount = clamp(fmModAmount, 0.f, 1.f);
        }

        // True Through-Zero FM (like Befaco Pony VCO)
        // Calculate base phase increment
        float basePhaseInc = finalFreq * args.sampleTime;

        // Calculate FM phase increment
        float fmPhaseInc = 0.0f;
        if (fmModAmount > 0.0f) {
            // Exponential scaling for more musical FM control
            float fmIndex = fmModAmount * fmModAmount * 4.f;  // Squared response, up to 4x

            // FM phase increment: frequency * FM signal * sample time
            // modSignalForModulation ranges from -1 to 1
            // When FM signal is negative, phase increment becomes negative (oscillator runs backwards)
            fmPhaseInc = finalFreq * modSignalForModulation * fmIndex * args.sampleTime;
        }

        // Total phase increment can be negative for true TZ-FM
        float finalDeltaPhase = basePhaseInc + fmPhaseInc;

        // Update final phase with TZ-FM phase increment (can be negative)
        finalPhase += finalDeltaPhase;

        // Get sync mode
        int syncMode = (int)params[SYNC_MODE].getValue();

        // Detect sync trigger BEFORE wrapping (when FINAL crosses 1.0)
        bool syncTrigger = false;
        if (finalPhase >= 1.0f && prevFinalPhase < 1.0f) {
            syncTrigger = true;
        }

        // Also detect negative crossing for TZ-FM
        if (finalPhase < 0.0f && prevFinalPhase >= 0.0f) {
            syncTrigger = true;
        }

        // Apply sync to MOD oscillator based on mode
        if (syncTrigger && syncMode > 0) {
            if (syncMode == 2) {
                // Hard sync: reset MOD phase immediately
                modPhase = 0.f;
            } else if (syncMode == 1) {
                // Soft sync: only reset MOD if its phase is in latter half
                if (modPhase > 0.5f) {
                    modPhase = 0.f;
                }
            }
        }

        // Wrap phase to [0, 1] using floor (like Befaco)
        finalPhase = finalPhase - std::floor(finalPhase);

        // Generate Buchla-style "sine" with harmonics
        // Base sine wave
        float fundamental = std::sin(2.f * M_PI * finalPhase);

        // Add 2nd harmonic (octave) with about 8% amplitude
        float harmonic2 = 0.08f * std::sin(4.f * M_PI * finalPhase);

        // Add 3rd harmonic with about 5% amplitude
        float harmonic3 = 0.05f * std::sin(6.f * M_PI * finalPhase);

        // Mix them together
        float finalSignal = fundamental + harmonic2 + harmonic3;

        // Normalize to maintain roughly -1 to 1 range
        finalSignal *= 0.92f; // Slight attenuation to prevent clipping

        // Apply VCA to oscillator outputs
        // Note: modOutputWithVca and modSignalForModulation were already calculated above for FM
        float finalOutput = finalSignal * 5.f;  // Raw final output (for scope)
        float finalOutputWithVca = finalOutput * finalVcaGain;  // Apply VCA

        // ===== FINAL Output Processing Chain: VCA -> Fold -> Order -> LPF =====

        // For FINAL output: Always process the raw signal, then apply VCA at the end
        // This allows the processing to work even when testing without triggers
        // finalSignal already contains the raw principal signal (±1)

        // 1. WAVEFOLDING - using HARMONICS knob (black knob at 125, 220)
        float foldAmount = smoothedHarmonics.process();
        // Apply CV modulation if connected
        if (inputs[HARMONICS_CV].isConnected()) {
            float foldCV = inputs[HARMONICS_CV].getVoltage() / 10.f;  // 0-10V to 0-1
            foldAmount += foldCV;
            foldAmount = clamp(foldAmount, 0.f, 1.f);
        }

        // Apply TM (Timbre Modulation) from Mod oscillator (post-VCA)
        float tmAmount = smoothedFoldAmt.process();  // Gray TM knob
        if (inputs[FOLD_AMT_CV].isConnected()) {
            float tmAttenuation = params[FOLD_AMT_ATTEN].getValue();  // White attenuator knob
            float tmCV = inputs[FOLD_AMT_CV].getVoltage() / 10.f;  // 0-10V to 0-1
            tmAmount += tmCV * tmAttenuation;
            tmAmount = clamp(tmAmount, 0.f, 1.f);
        }
        if (tmAmount > 0.0f) {
            // Modulate the fold amount with the post-VCA mod signal
            // modSignalForModulation ranges from -1 to 1, convert to 0-1 for unipolar modulation
            float timbreModulation = (modSignalForModulation * 0.5f + 0.5f) * tmAmount;
            foldAmount += timbreModulation;  // Add full range modulation (0 to 1)
            foldAmount = clamp(foldAmount, 0.f, 1.f);
        }

        if (foldAmount > 0.0f) {
            finalSignal = wavefold(finalSignal, foldAmount);
        }

        // 2. RECTIFY (Asymmetric rectifier for harmonic generation, after VCA)
        float rectifyAmount = smoothedOrder.process();
        // Apply CV modulation if connected
        if (inputs[ORDER_CV].isConnected()) {
            float rectifyCV = inputs[ORDER_CV].getVoltage() / 10.f;  // 0-10V to 0-1
            rectifyAmount += rectifyCV;
            rectifyAmount = clamp(rectifyAmount, 0.f, 1.f);
        }

        // Apply RECT Modulation from Mod oscillator (post-VCA)
        float rectModAmount = smoothedSymAmt.process();  // Gray knob (now RECT Mod)
        if (inputs[AM_AMT_CV].isConnected()) {
            float rectModAttenuation = params[AM_AMT_ATTEN].getValue();  // White attenuator knob
            float rectModCV = inputs[AM_AMT_CV].getVoltage() / 10.f;  // 0-10V to 0-1
            rectModAmount += rectModCV * rectModAttenuation;
            rectModAmount = clamp(rectModAmount, 0.f, 1.f);
        }
        if (rectModAmount > 0.0f) {
            // Modulate rectification with the post-VCA mod signal
            // modSignalForModulation ranges from -1 to 1, convert to unipolar for modulation
            float rectModulation = (modSignalForModulation * 0.5f + 0.5f) * rectModAmount;
            rectifyAmount += rectModulation;  // Add full modulation range (up to 100%)
            rectifyAmount = clamp(rectifyAmount, 0.f, 1.f);
        }

        finalSignal = asymmetricRectifier(finalSignal, rectifyAmount);

        // 3. LOWPASS FILTER (after VCA)
        float lpfCutoffParam = smoothedLpfCutoff.process();  // 0-1
        // Map parameter to frequency range (100Hz - 20kHz, exponential)
        float lpfCutoff = 100.f * std::pow(200.f, lpfCutoffParam);  // 100Hz * (200^param) = 100Hz to 20kHz

        // Apply CV modulation if connected
        if (inputs[LPF_CUTOFF_CV].isConnected()) {
            float lpfCV = inputs[LPF_CUTOFF_CV].getVoltage() / 10.f;  // 0-10V to 0-1
            float cvAmount = lpfCV * 2.f - 1.f;  // Convert to bipolar -1 to 1
            // Apply exponential CV scaling
            lpfCutoff *= std::pow(2.f, cvAmount * 2.f);  // ±2 octaves per ±1 CV
        }

        // Clamp cutoff to valid range
        lpfCutoff = clamp(lpfCutoff, 20.f, args.sampleRate * 0.49f);

        // Update and apply filter
        lpFilter.setCutoff(lpfCutoff);
        finalSignal = lpFilter.process(finalSignal);

        // Apply VCA at the end (after all processing) and scale to ±5V range
        finalOutputWithVca = finalSignal * 5.f * finalVcaGain;

        // BASS knob: Add clean sine to processed signal (with soft clipping)
        float bassAmount = smoothedBass.process();  // 0 to 1
        if (bassAmount > 0.0f) {
            // finalOutput contains the clean sine (before processing)
            // finalOutputWithVca contains the processed signal
            // Add sine directly to the processed signal, scaled up to 2x for stronger effect
            float cleanSine = finalOutput * finalVcaGain * bassAmount * 2.0f;  // Scale sine by bass amount * 2
            finalOutputWithVca = finalOutputWithVca + cleanSine;

            // Soft clipping using tanh to prevent clipping while maintaining musicality
            // Only apply soft clipping if the signal exceeds ±5V
            if (std::abs(finalOutputWithVca) > 5.0f) {
                float sign = finalOutputWithVca > 0 ? 1.0f : -1.0f;
                // Soft clip the excess above 5V
                float excess = std::abs(finalOutputWithVca) - 5.0f;
                finalOutputWithVca = sign * (5.0f + std::tanh(excess * 0.3f) * 2.0f);
            }
        }

        // Set outputs
        outputs[MOD_SIGNAL_OUT].setVoltage(modOutputWithVca);
        outputs[FINAL_SINE_OUT].setVoltage(finalOutput * finalVcaGain);  // Clean sine output (with VCA)
        outputs[FINAL_FINAL_OUT].setVoltage(finalOutputWithVca);  // Mixed output with Bass control

        // Trigger light control (exactly like Observer)
        bool trig = !params[TRIG_PARAM].getValue();
        lights[TRIG_LIGHT].setBrightness(trig);

        // Detect trigger if no longer recording (100% copy from VCV Scope)
        if (bufferIndex >= SCOPE_BUFFER_SIZE) {
            bool triggered = false;

            // Trigger immediately if trigger detection is disabled
            if (!trig) {
                triggered = true;
            }
            else {
                // Reset if triggered - use FINAL output as trigger source
                // Using exact rescale from Observer: 0.f to 0.001f range
                float trigVoltage = finalOutput;
                if (scopeTriggers[0].process(rescale(trigVoltage, 0.f, 0.001f, 0.f, 1.f))) {
                    triggered = true;
                }
            }

            if (triggered) {
                for (int c = 0; c < 16; c++) {
                    scopeTriggers[c].reset();
                }
                bufferIndex = 0;
                frameIndex = 0;
            }
        }

        // Add point to buffer if recording (100% copy from Observer logic)
        if (bufferIndex < SCOPE_BUFFER_SIZE) {
            // Compute time
            float deltaTime = dsp::exp2_taylor5(-params[SCOPE_TIME].getValue()) / SCOPE_BUFFER_SIZE;
            int frameCount = (int) std::ceil(deltaTime * args.sampleRate);

            // Get VCA-processed outputs for scope display
            // Show the actual output that goes to the jacks
            float modSample = modOutputWithVca / 5.0f - 1.0f;  // Convert 0-10V to -1..1
            float finalSample = finalOutputWithVca / 5.0f;  // ±5V to ±1 for display
            currentFinal.min = std::min(currentFinal.min, finalSample);
            currentFinal.max = std::max(currentFinal.max, finalSample);
            currentMod.min = std::min(currentMod.min, modSample);
            currentMod.max = std::max(currentMod.max, modSample);

            if (++frameIndex >= frameCount) {
                frameIndex = 0;
                // Push current point
                finalBuffer[bufferIndex] = currentFinal;
                modBuffer[bufferIndex] = currentMod;
                // Reset current point
                currentFinal = ScopePoint();
                currentMod = ScopePoint();
                bufferIndex++;
            }
        }
    }
};

// ===== Dual-track Scope Display Widget =====
struct VisualDisplay : Widget {
    NIGOQ* module;

    VisualDisplay(NIGOQ* module) : module(module) {
        box.size = Vec(66, 38.5);
    }

    void draw(const DrawArgs& args) override {
        if (!module) return;

        // Draw background
        nvgBeginPath(args.vg);
        nvgRect(args.vg, 0, 0, box.size.x, box.size.y);
        nvgFillColor(args.vg, nvgRGB(20, 20, 20));
        nvgFill(args.vg);

        // Draw border
        nvgStrokeWidth(args.vg, 1.0f);
        nvgStrokeColor(args.vg, nvgRGBA(100, 100, 100, 255));
        nvgStroke(args.vg);

        // Draw center line
        float centerY = box.size.y / 2;
        nvgBeginPath(args.vg);
        nvgMoveTo(args.vg, 0, centerY);
        nvgLineTo(args.vg, box.size.x, centerY);
        nvgStrokeColor(args.vg, nvgRGBA(255, 255, 255, 30));
        nvgStrokeWidth(args.vg, 0.5f);
        nvgStroke(args.vg);

        // Draw PRIN trace (top half, pink)
        float trackHeight = box.size.y / 2.0f;
        float trackY = 0;

        nvgSave(args.vg);
        Rect b = Rect(Vec(0, trackY), Vec(box.size.x, trackHeight));
        nvgScissor(args.vg, RECT_ARGS(b));
        nvgBeginPath(args.vg);

        for (int i = 0; i < NIGOQ::SCOPE_BUFFER_SIZE; i++) {
            const NIGOQ::ScopePoint& point = module->finalBuffer[i];
            float value = point.max;
            if (!std::isfinite(value))
                value = 0.f;

            Vec p;
            p.x = (float)i / (NIGOQ::SCOPE_BUFFER_SIZE - 1) * b.size.x;
            // Scale signal properly (already normalized to +/-1 in process)
            p.y = b.pos.y + b.size.y * 0.5f * (1.f - value);

            if (i == 0)
                nvgMoveTo(args.vg, p.x, p.y);
            else
                nvgLineTo(args.vg, p.x, p.y);
        }

        nvgStrokeColor(args.vg, nvgRGB(255, 133, 133)); // Pink
        nvgStrokeWidth(args.vg, 1.0f);
        nvgStroke(args.vg);
        nvgResetScissor(args.vg);
        nvgRestore(args.vg);

        // Draw MOD trace (bottom half, cyan)
        trackY = trackHeight;

        nvgSave(args.vg);
        b = Rect(Vec(0, trackY), Vec(box.size.x, trackHeight));
        nvgScissor(args.vg, RECT_ARGS(b));
        nvgBeginPath(args.vg);

        for (int i = 0; i < NIGOQ::SCOPE_BUFFER_SIZE; i++) {
            const NIGOQ::ScopePoint& point = module->modBuffer[i];
            float value = point.max;
            if (!std::isfinite(value))
                value = 0.f;

            Vec p;
            p.x = (float)i / (NIGOQ::SCOPE_BUFFER_SIZE - 1) * b.size.x;
            // Scale signal properly (already normalized to +/-1 in process)
            p.y = b.pos.y + b.size.y * 0.5f * (1.f - value);

            if (i == 0)
                nvgMoveTo(args.vg, p.x, p.y);
            else
                nvgLineTo(args.vg, p.x, p.y);
        }

        nvgStrokeColor(args.vg, nvgRGB(133, 200, 255)); // Cyan
        nvgStrokeWidth(args.vg, 1.0f);
        nvgStroke(args.vg);
        nvgResetScissor(args.vg);
        nvgRestore(args.vg);
    }
};

// ===== Clickable Light Button =====
struct ClickableLight : ParamWidget {
    NIGOQ* module;

    ClickableLight() {
        box.size = Vec(8, 8);
    }

    void draw(const DrawArgs& args) override {
        if (!module) return;

        float brightness = module->lights[NIGOQ::TRIG_LIGHT].getBrightness();

        nvgBeginPath(args.vg);
        nvgCircle(args.vg, box.size.x / 2, box.size.y / 2, box.size.x / 2 - 1);

        if (brightness > 0.5f) {
            // Pink when trigger is disabled (free running)
            nvgFillColor(args.vg, nvgRGB(255, 133, 133));
        } else {
            // Dark gray when trigger is enabled (waiting for trigger)
            nvgFillColor(args.vg, nvgRGB(80, 80, 80));
        }
        nvgFill(args.vg);

        nvgStrokeColor(args.vg, nvgRGB(200, 200, 200));
        nvgStrokeWidth(args.vg, 0.5f);
        nvgStroke(args.vg);
    }

    void onButton(const event::Button& e) override {
        if (e.action == GLFW_PRESS && e.button == GLFW_MOUSE_BUTTON_LEFT) {
            ParamQuantity* pq = getParamQuantity();
            if (pq) {
                float newValue = pq->getValue() > 0.5f ? 0.f : 1.f;
                pq->setValue(newValue);
            }
            e.consume(this);
        }
    }
};

// ===== Module Widget =====
struct NIGOQWidget : ModuleWidget {
    NIGOQWidget(NIGOQ* module) {
        setModule(module);
        setPanel(APP->window->loadSvg(asset::plugin(pluginInstance, "res/12HP.svg")));


        // Title labels
        addChild(new EnhancedTextLabel(Vec(0, 1), Vec(180, 20), "N I G O Q", 12.f, nvgRGB(255, 200, 0), true));
        addChild(new EnhancedTextLabel(Vec(0, 13), Vec(180, 20), "MADZINE", 10.f, nvgRGB(255, 200, 0), false));

        // White background box
        addChild(new WhiteBackgroundBox(Vec(0, 330), Vec(box.size.x, 50)));

        // "259" Numbers
        addChild(new NumberWithBorder(Vec(20, 248), Vec(30, 35), "2", 72.f, nvgRGB(255, 255, 255), nvgRGB(0, 0, 0)));
        addChild(new NumberWithBorder(Vec(45, 248), Vec(30, 35), "5", 72.f, nvgRGB(255, 255, 255), nvgRGB(0, 0, 0)));
        addChild(new NumberWithBorder(Vec(70, 248), Vec(30, 35), "9", 72.f, nvgRGB(255, 255, 255), nvgRGB(0, 0, 0)));

        // Inputs
        addInput(createInputCentered<PJ301MPort>(Vec(165, 55), module, NIGOQ::TRIG_IN));
        addInput(createInputCentered<PJ301MPort>(Vec(20, 95), module, NIGOQ::MOD_WAVE_CV));
        addInput(createInputCentered<PJ301MPort>(Vec(165, 130), module, NIGOQ::LPF_CUTOFF_CV));
        addInput(createInputCentered<PJ301MPort>(Vec(165, 175), module, NIGOQ::ORDER_CV));
        addInput(createInputCentered<PJ301MPort>(Vec(20, 130), module, NIGOQ::FM_AMT_CV));
        addInput(createInputCentered<PJ301MPort>(Vec(165, 220), module, NIGOQ::HARMONICS_CV));
        addInput(createInputCentered<PJ301MPort>(Vec(20, 220), module, NIGOQ::FOLD_AMT_CV));
        addInput(createInputCentered<PJ301MPort>(Vec(20, 175), module, NIGOQ::AM_AMT_CV));
        addInput(createInputCentered<PJ301MPort>(Vec(50, 310), module, NIGOQ::MOD_FM_IN));
        addInput(createInputCentered<PJ301MPort>(Vec(20, 310), module, NIGOQ::MOD_1VOCT));
        addInput(createInputCentered<PJ301MPort>(Vec(135, 310), module, NIGOQ::FINAL_FM_IN));
        addInput(createInputCentered<PJ301MPort>(Vec(165, 310), module, NIGOQ::FINAL_1VOCT));

        // Large white knobs with custom param quantities
        addParam(createParamCentered<LargeWhiteKnob>(Vec(55, 65), module, NIGOQ::MOD_FREQ));
        addParam(createParamCentered<LargeWhiteKnob>(Vec(125, 65), module, NIGOQ::FINAL_FREQ));

        // Custom ParamQuantities are now configured in NIGOQ constructor via configParam<>

        // Standard black knobs
        addParam(createParamCentered<RoundBlackKnob>(Vec(125, 130), module, NIGOQ::LPF_CUTOFF));
        addParam(createParamCentered<RoundBlackKnob>(Vec(125, 175), module, NIGOQ::ORDER));
        addParam(createParamCentered<RoundBlackKnob>(Vec(125, 220), module, NIGOQ::HARMONICS));

        // Small white knobs
        addParam(createParamCentered<SmallWhiteKnob>(Vec(20, 55), module, NIGOQ::MOD_WAVE));
        addParam(createParamCentered<SmallWhiteKnob>(Vec(55, 130), module, NIGOQ::FM_AMT_ATTEN));
        addParam(createParamCentered<SmallWhiteKnob>(Vec(55, 220), module, NIGOQ::FOLD_AMT_ATTEN));
        addParam(createParamCentered<SmallWhiteKnob>(Vec(55, 175), module, NIGOQ::AM_AMT_ATTEN));
        addParam(createParamCentered<SmallWhiteKnob>(Vec(77, 310), module, NIGOQ::MOD_FM_ATTEN));
        addParam(createParamCentered<SmallWhiteKnob>(Vec(108, 310), module, NIGOQ::FINAL_FM_ATTEN));

        // Small gray knobs
        addParam(createParamCentered<SmallGrayKnob>(Vec(165, 90), module, NIGOQ::DECAY));
        addParam(createParamCentered<SmallGrayKnob>(Vec(165, 265), module, NIGOQ::BASS));
        addParam(createParamCentered<SmallGrayKnob>(Vec(90, 130), module, NIGOQ::FM_AMT));
        addParam(createParamCentered<SmallGrayKnob>(Vec(90, 220), module, NIGOQ::FOLD_AMT));
        addParam(createParamCentered<SmallGrayKnob>(Vec(90, 175), module, NIGOQ::AM_AMT));

        // Switch
        addParam(createParamCentered<CKSSThree>(Vec(90, 85), module, NIGOQ::SYNC_MODE));

        // Input labels
        addChild(new EnhancedTextLabel(Vec(145, 34), Vec(40, 10), "TRIG", 7.f, nvgRGB(255, 255, 255), true));
        addChild(new EnhancedTextLabel(Vec(0, 74), Vec(40, 10), "WAVE", 7.f, nvgRGB(255, 255, 255), true));
        addChild(new EnhancedTextLabel(Vec(145, 109), Vec(40, 10), "LPF", 7.f, nvgRGB(255, 255, 255), true));
        addChild(new EnhancedTextLabel(Vec(145, 154), Vec(40, 10), "RECT", 7.f, nvgRGB(255, 255, 255), true));
        addChild(new EnhancedTextLabel(Vec(0, 109), Vec(40, 10), "FM", 7.f, nvgRGB(255, 255, 255), true));
        addChild(new EnhancedTextLabel(Vec(145, 199), Vec(40, 10), "FOLD", 7.f, nvgRGB(255, 255, 255), true));
        addChild(new EnhancedTextLabel(Vec(0, 199), Vec(40, 10), "TM", 7.f, nvgRGB(255, 255, 255), true));
        addChild(new EnhancedTextLabel(Vec(0, 154), Vec(40, 10), "RECT", 7.f, nvgRGB(255, 255, 255), true));
        addChild(new EnhancedTextLabel(Vec(30, 289), Vec(40, 10), "M.FM", 7.f, nvgRGB(255, 255, 255), true));
        addChild(new EnhancedTextLabel(Vec(0, 289), Vec(40, 10), "M.V/O", 7.f, nvgRGB(255, 255, 255), true));
        addChild(new EnhancedTextLabel(Vec(115, 289), Vec(40, 10), "F.FM", 7.f, nvgRGB(255, 255, 255), true));
        addChild(new EnhancedTextLabel(Vec(145, 289), Vec(40, 10), "F.V/O", 7.f, nvgRGB(255, 255, 255), true));

        // Parameter labels
        addChild(new EnhancedTextLabel(Vec(23, 36), Vec(64, 15), "MOD FREQ", 7.f, nvgRGB(255, 255, 255), true));
        addChild(new EnhancedTextLabel(Vec(93, 36), Vec(64, 15), "FINAL FREQ", 7.f, nvgRGB(255, 255, 255), true));
        addChild(new EnhancedTextLabel(Vec(93, 103), Vec(64, 12), "LPF", 7.f, nvgRGB(255, 255, 255), true));
        addChild(new EnhancedTextLabel(Vec(102, 148), Vec(46, 12), "RECTIFY", 7.f, nvgRGB(255, 255, 255), true));
        addChild(new EnhancedTextLabel(Vec(90, 193), Vec(70, 12), "FOLD", 7.f, nvgRGB(255, 255, 255), true));

        // Small knob labels
        addChild(new EnhancedTextLabel(Vec(4, 34), Vec(30, 12), "WAVE", 7.f, nvgRGB(255, 255, 255), true));
        addChild(new EnhancedTextLabel(Vec(30, 109), Vec(50, 10), "CV ATT", 7.f, nvgRGB(255, 255, 255), true));
        addChild(new EnhancedTextLabel(Vec(30, 199), Vec(50, 10), "CV ATT", 7.f, nvgRGB(255, 255, 255), true));
        addChild(new EnhancedTextLabel(Vec(30, 154), Vec(50, 10), "CV ATT", 7.f, nvgRGB(255, 255, 255), true));
        addChild(new EnhancedTextLabel(Vec(62, 289), Vec(30, 10), "M.FM", 7.f, nvgRGB(255, 255, 255), true));
        addChild(new EnhancedTextLabel(Vec(93, 289), Vec(30, 10), "F.FM", 7.f, nvgRGB(255, 255, 255), true));

        // Gray knob labels
        addChild(new EnhancedTextLabel(Vec(150, 67), Vec(30, 10), "DEC", 7.f, nvgRGB(255, 255, 255), true));
        addChild(new EnhancedTextLabel(Vec(150, 242), Vec(30, 10), "BASS", 7.f, nvgRGB(255, 255, 255), true));
        addChild(new EnhancedTextLabel(Vec(78, 107), Vec(25, 12), "FM", 7.f, nvgRGB(255, 255, 255), true));
        addChild(new EnhancedTextLabel(Vec(75, 197), Vec(30, 12), "TM", 7.f, nvgRGB(255, 255, 255), true));
        addChild(new EnhancedTextLabel(Vec(78, 152), Vec(25, 12), "RECT", 7.f, nvgRGB(255, 255, 255), true));

        // Switch label
        addChild(new EnhancedTextLabel(Vec(75, 60), Vec(30, 12), "SYNC", 7.f, nvgRGB(255, 255, 255), true));

        // Add scope display
        VisualDisplay* scopeDisplay = new VisualDisplay(module);
        scopeDisplay->box.pos = Vec(40, 335);
        addChild(scopeDisplay);
        if (module) {
            module->visualDisplay = scopeDisplay;
        }

        // Hidden time knob (overlaps scope display)
        addParam(createParam<HiddenTimeKnob>(Vec(40, 335), module, NIGOQ::SCOPE_TIME));

        // Trigger light button (to the right of scope)
        ClickableLight* trigLight = createParam<ClickableLight>(Vec(110, 330), module, NIGOQ::TRIG_PARAM);
        trigLight->module = module;
        addParam(trigLight);

        // Outputs
        addOutput(createOutputCentered<PJ301MPort>(Vec(20, 360), module, NIGOQ::MOD_SIGNAL_OUT));
        addOutput(createOutputCentered<PJ301MPort>(Vec(135, 360), module, NIGOQ::FINAL_SINE_OUT));
        addOutput(createOutputCentered<PJ301MPort>(Vec(165, 360), module, NIGOQ::FINAL_FINAL_OUT));

        // Output labels (pink color)
        addChild(new EnhancedTextLabel(Vec(0, 339), Vec(40, 10), "MOD", 7.f, nvgRGB(255, 133, 133), true));
        addChild(new EnhancedTextLabel(Vec(120, 339), Vec(30, 10), "SINE", 7.f, nvgRGB(255, 133, 133), true));
        addChild(new EnhancedTextLabel(Vec(145, 339), Vec(40, 10), "FINAL", 7.f, nvgRGB(255, 133, 133), true));
    }

    void appendContextMenu(Menu* menu) override {
        NIGOQ* module = dynamic_cast<NIGOQ*>(this->module);
        if (!module) return;

        menu->addChild(new MenuSeparator);

        menu->addChild(createMenuLabel("Oversampling"));

        struct OversampleMenuItem : MenuItem {
            NIGOQ* module;
            int oversampleRate;
            void onAction(const event::Action& e) override {
                module->oversampleRate = oversampleRate;
                module->setupOversamplingFilters();
            }
        };

        auto addOversampleItem = [&](const char* label, int rate) {
            OversampleMenuItem* item = createMenuItem<OversampleMenuItem>(label, CHECKMARK(module->oversampleRate == rate));
            item->module = module;
            item->oversampleRate = rate;
            menu->addChild(item);
        };

        addOversampleItem("Off (x1)", 1);
        addOversampleItem("x2", 2);
        addOversampleItem("x4", 4);
        addOversampleItem("x8", 8);
        addOversampleItem("x16", 16);
        addOversampleItem("x32", 32);

        menu->addChild(new MenuSeparator);

        menu->addChild(createMenuLabel("Filter Quality"));

        struct FilterQualityMenuItem : MenuItem {
            NIGOQ* module;
            int quality;
            void onAction(const event::Action& e) override {
                module->oversampleQuality = quality;
                // Quality affects filter coefficients, but we keep it simple for now
            }
        };

        auto addQualityItem = [&](const char* label, int quality) {
            FilterQualityMenuItem* item = createMenuItem<FilterQualityMenuItem>(label, CHECKMARK(module->oversampleQuality == quality));
            item->module = module;
            item->quality = quality;
            menu->addChild(item);
        };

        addQualityItem("Low (fast, minimal CPU)", 0);
        addQualityItem("Medium (balanced)", 1);
        addQualityItem("High (best quality)", 2);

        menu->addChild(new MenuSeparator);

        menu->addChild(createMenuLabel("Attack Time"));

        struct AttackTimeSlider : ui::Slider {
            struct AttackTimeQuantity : Quantity {
                NIGOQ* module;
                AttackTimeQuantity(NIGOQ* module) : module(module) {}

                void setValue(float value) override {
                    if (module) {
                        value = clamp(value, 0.0f, 1.0f);
                        // Map 0-1 to 0.1ms - 100ms with exponential scaling
                        float minAttack = 0.0001f;  // 0.1 ms
                        float maxAttack = 0.1f;     // 100 ms
                        // Exponential mapping for better control at low values
                        module->attackTime = minAttack * std::pow(maxAttack / minAttack, value);
                    }
                }

                float getValue() override {
                    if (module) {
                        float minAttack = 0.0001f;
                        float maxAttack = 0.1f;
                        // Reverse exponential mapping
                        return std::log(module->attackTime / minAttack) / std::log(maxAttack / minAttack);
                    }
                    return 0.21f;  // Default position for 1ms
                }

                float getMinValue() override { return 0.0f; }
                float getMaxValue() override { return 1.0f; }
                float getDefaultValue() override { return 0.21f; }  // Default for 1ms
                std::string getLabel() override { return "Attack Time"; }
                std::string getUnit() override { return " ms"; }
                std::string getDisplayValueString() override {
                    if (module) {
                        float ms = module->attackTime * 1000.0f;
                        if (ms < 1.0f) {
                            return string::f("%.2f", ms);
                        } else if (ms < 10.0f) {
                            return string::f("%.1f", ms);
                        } else {
                            return string::f("%.0f", ms);
                        }
                    }
                    return "1.00";
                }
            };

            AttackTimeSlider(NIGOQ* module) {
                box.size.x = 200.0f;
                quantity = new AttackTimeQuantity(module);
            }

            ~AttackTimeSlider() {
                delete quantity;
            }
        };

        AttackTimeSlider* slider = new AttackTimeSlider(module);

        struct AttackTimeDisplay : ui::MenuLabel {
            NIGOQ* module;

            AttackTimeDisplay(NIGOQ* module) : module(module) {
                text = "1.00 ms";
            }

            void step() override {
                if (module) {
                    float ms = module->attackTime * 1000.0f;
                    if (ms < 1.0f) {
                        text = string::f("%.2f ms", ms);
                    } else if (ms < 10.0f) {
                        text = string::f("%.1f ms", ms);
                    } else {
                        text = string::f("%.0f ms", ms);
                    }
                }
                ui::MenuLabel::step();
            }
        };

        AttackTimeDisplay* display = new AttackTimeDisplay(module);

        menu->addChild(slider);
        menu->addChild(display);

        menu->addChild(new MenuSeparator);

        // Randomize Glide Time Slider
        menu->addChild(createMenuLabel("Randomize Glide Time"));

        struct GlideTimeSlider : ui::Slider {
            struct GlideTimeQuantity : Quantity {
                NIGOQ* module;
                GlideTimeQuantity(NIGOQ* module) : module(module) {}

                void setValue(float value) override {
                    if (module) {
                        value = clamp(value, 0.0f, 1.0f);
                        // Map 0-1 to 0.1s - 30s with exponential scaling for better control
                        float minGlide = 0.1f;   // 0.1 seconds
                        float maxGlide = 30.0f;   // 30 seconds
                        // Exponential mapping for more precision at low values
                        module->randomizeGlideTime = minGlide * std::pow(maxGlide / minGlide, value);
                    }
                }

                float getValue() override {
                    if (module) {
                        float minGlide = 0.1f;
                        float maxGlide = 30.0f;
                        // Reverse exponential mapping
                        return std::log(module->randomizeGlideTime / minGlide) / std::log(maxGlide / minGlide);
                    }
                    return 0.37f;  // Default position for 1s
                }

                float getMinValue() override { return 0.0f; }
                float getMaxValue() override { return 1.0f; }
                float getDefaultValue() override { return 0.37f; }  // Default for 1s
                std::string getLabel() override { return "Glide Time"; }
                std::string getUnit() override { return " s"; }
                std::string getDisplayValueString() override {
                    if (module) {
                        if (module->randomizeGlideTime < 1.0f) {
                            return string::f("%.2f", module->randomizeGlideTime);
                        } else if (module->randomizeGlideTime < 10.0f) {
                            return string::f("%.1f", module->randomizeGlideTime);
                        } else {
                            return string::f("%.0f", module->randomizeGlideTime);
                        }
                    }
                    return "1.00";
                }
            };

            GlideTimeSlider(NIGOQ* module) {
                box.size.x = 200.0f;
                quantity = new GlideTimeQuantity(module);
            }

            ~GlideTimeSlider() {
                delete quantity;
            }
        };

        GlideTimeSlider* glideSlider = new GlideTimeSlider(module);
        menu->addChild(glideSlider);

        menu->addChild(new MenuSeparator);

        // Random Amount Slider
        menu->addChild(createMenuLabel("Random Amount"));

        struct RandomAmountSlider : ui::Slider {
            struct RandomAmountQuantity : Quantity {
                NIGOQ* module;
                RandomAmountQuantity(NIGOQ* module) : module(module) {}

                void setValue(float value) override {
                    if (module) {
                        module->randomAmount = clamp(value, 0.0f, 1.0f);
                    }
                }

                float getValue() override {
                    if (module) {
                        return module->randomAmount;
                    }
                    return 1.0f;
                }

                float getMinValue() override { return 0.0f; }
                float getMaxValue() override { return 1.0f; }
                float getDefaultValue() override { return 1.0f; }
                std::string getLabel() override { return "Amount"; }
                std::string getUnit() override { return "%"; }
                std::string getDisplayValueString() override {
                    if (module) {
                        return string::f("%.0f", module->randomAmount * 100.0f);
                    }
                    return "100";
                }
            };

            RandomAmountSlider(NIGOQ* module) {
                box.size.x = 200.0f;
                quantity = new RandomAmountQuantity(module);
            }

            ~RandomAmountSlider() {
                delete quantity;
            }
        };

        RandomAmountSlider* amountSlider = new RandomAmountSlider(module);
        menu->addChild(amountSlider);
    }
};

Model* modelNIGOQ = createModel<NIGOQ, NIGOQWidget>("NIGOQ");