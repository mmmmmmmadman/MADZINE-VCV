#!/usr/bin/env python3
"""Generate ManualHelpData.hpp from Manual/modules/*.json"""

import json
import os
import re
import html as html_module

SLUG_TO_FILE = {
    "SwingLFO": "swing_lfo",
    "EuclideanRhythm": "euclidean_rhythm",
    "ADGenerator": "ad_generator",
    "Pinpple": "pinpple",
    "PPaTTTerning": "ppattterning",
    "MADDY": "maddy",
    "TWNC": "twnc",
    "TWNCLight": "twnc_light",
    "TWNC2": "twnc_2",
    "QQ": "q_q",
    "Observer": "observer",
    "U8": "u8",
    "YAMANOTE": "yamanote",
    "KIMO": "kimo",
    "Obserfour": "obserfour",
    "Pyramid": "pyramid",
    "DECAPyramid": "decapyramid",
    "KEN": "ken",
    "Quantizer": "quantizer",
    "EllenRipley": "ellen_ripley",
    "MADDYPlus": "maddy_",
    "NIGOQ": "nigoq",
    "Runshow": "runshow",
    "EnvVCA6": "env_vca_6",
    "WeiiiDocumenta": "weiii_documenta",
    "UniversalRhythm": "universal_rhythm",
    "UniRhythm": "uni_rhythm",
    "SongMode": "songmode",
    "Launchpad": "launchpad",
    "Runner": "runner",
    "Facehugger": "facehugger",
    "Ovomorph": "ovomorph",
    "ALEXANDERPLATZ": "alexanderplatz",
    "SHINJUKU": "shinjuku",
    "Portal": "portal",
    "Drummmmmmer": "drummmmmmer",
    "theKICK": "thekick",
}


def strip_html(text):
    text = re.sub(r'<[^>]+>', '', text)
    text = html_module.unescape(text)
    text = re.sub(r'\s+', ' ', text)
    return text.strip()


def extract_entries(html_str):
    entries = []
    pattern = r'<b>([^<]+)</b>\s*[:\uff1a]\s*((?:(?!</li>|</ul>|</p>|<h3).)*)'
    for m in re.finditer(pattern, html_str, re.DOTALL):
        name = m.group(1).strip()
        desc = strip_html(m.group(2)).strip()
        if desc and len(name) < 50:
            entries.append((name, desc))
    return entries


def escape_cpp(s):
    s = s.replace('\\', '\\\\')
    s = s.replace('"', '\\"')
    s = s.replace('\n', '\\n')
    s = s.replace('\t', '\\t')
    return s


def main():
    modules_dir = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'modules')
    output_path = os.path.join(os.path.dirname(os.path.abspath(__file__)), '..', 'src', 'ManualHelpData.hpp')

    lines = []
    lines.append('// Auto-generated by Manual/generate_help_data.py')
    lines.append('// Do not edit manually')
    lines.append('#pragma once')
    lines.append('#include <string>')
    lines.append('#include <map>')
    lines.append('#include <vector>')
    lines.append('#include <algorithm>')
    lines.append('')
    lines.append('struct HelpEntry {')
    lines.append('    std::string en;')
    lines.append('    std::string zh;')
    lines.append('    std::string ja;')
    lines.append('    const std::string& get(const std::string& lang) const {')
    lines.append('        if (lang == "zh") return zh;')
    lines.append('        if (lang == "ja") return ja;')
    lines.append('        return en;')
    lines.append('    }')
    lines.append('};')
    lines.append('')
    lines.append('struct ModuleHelpData {')
    lines.append('    std::string name;')
    lines.append('    HelpEntry description;')
    lines.append('    std::vector<std::pair<std::string, HelpEntry>> entries;')
    lines.append('};')
    lines.append('')
    lines.append('inline std::map<std::string, ModuleHelpData> initHelpData() {')
    lines.append('    std::map<std::string, ModuleHelpData> data;')

    total_entries = 0

    for slug, filename in sorted(SLUG_TO_FILE.items()):
        json_path = os.path.join(modules_dir, f'{filename}.json')
        if not os.path.exists(json_path):
            print(f'  WARNING: {json_path} not found, skipping {slug}')
            continue

        with open(json_path, 'r', encoding='utf-8') as f:
            d = json.load(f)

        name = d.get('name', slug)
        desc_en = d.get('description', '')
        desc_zh = d.get('description_zh', desc_en)
        desc_ja = d.get('description_ja', desc_en)

        manual_en = d.get('manual', '')
        manual_zh = d.get('manual_zh', '')
        manual_ja = d.get('manual_ja', '')

        entries_en = extract_entries(manual_en)
        entries_zh = {n.upper(): desc for n, desc in extract_entries(manual_zh)}
        entries_ja = {n.upper(): desc for n, desc in extract_entries(manual_ja)}

        lines.append(f'    // {slug} ({len(entries_en)} entries)')
        lines.append('    {')
        lines.append('        ModuleHelpData m;')
        lines.append(f'        m.name = "{escape_cpp(name)}";')
        lines.append(f'        m.description = {{"{escape_cpp(desc_en)}", "{escape_cpp(desc_zh)}", "{escape_cpp(desc_ja)}"}};')

        for ename, edesc in entries_en:
            key = ename.upper()
            zh = entries_zh.get(key, edesc)
            ja = entries_ja.get(key, edesc)
            lines.append(f'        m.entries.push_back({{"{escape_cpp(ename)}", {{"{escape_cpp(edesc)}", "{escape_cpp(zh)}", "{escape_cpp(ja)}"}}}});')
            total_entries += 1

        lines.append(f'        data["{slug}"] = std::move(m);')
        lines.append('    }')

    lines.append('    return data;')
    lines.append('}')

    with open(output_path, 'w', encoding='utf-8') as f:
        f.write('\n'.join(lines) + '\n')

    print(f'Generated {output_path}')
    print(f'  {len(SLUG_TO_FILE)} modules, {total_entries} entries total')


if __name__ == '__main__':
    main()
